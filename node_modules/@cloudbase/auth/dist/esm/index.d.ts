import type { ICloudbase, ICloudbaseConfig } from '@cloudbase/types';
import type { ICloudbaseCache } from '@cloudbase/types/cache';
import type { ICloudbaseRequest } from '@cloudbase/types/request';
import type { ICloudbaseAuthConfig, IUser, IUserInfo, ILoginState } from '@cloudbase/types/auth';
import type { ProviderSubType } from '@cloudbase/oauth/dist/cjs/auth/models';
import type { authModels, AuthOptions, Credentials } from '@cloudbase/oauth';
import { CloudbaseOAuth } from '@cloudbase/oauth';
import { SbaseApi } from './sbaseApi';
export type { SignInRes, GetUserRes, CommonRes, SignInWithOtpRes, SignInOAuthRes, GetClaimsRes, ResetPasswordForEmailRes, GetUserIdentitiesRes, LinkIdentityRes, ReauthenticateRes, ResendRes, UpdateUserWithVerificationRes, OnAuthStateChangeCallback, SignInWithPasswordReq, SignInWithIdTokenReq, SignInWithOAuthReq, VerifyOAuthReq, VerifyOtpReq, LinkIdentityReq, UnlinkIdentityReq, UpdateUserReq, SignInWithOtpReq, ResetPasswordForOldReq, ResendReq, SetSessionReq, DeleteMeReq, SignUpRes, } from './type';
interface UserInfo {
    uid?: string;
    gender?: string;
    picture?: string;
    email?: string;
    email_verified?: boolean;
    phone_number?: string;
    username?: string;
    name?: string;
    birthdate?: string;
    zoneinfo?: string;
    locale?: string;
    sub?: string;
    created_from?: string;
}
interface IUserOptions {
    cache: ICloudbaseCache;
    oauthInstance: CloudbaseOAuth;
}
export declare class User implements IUser {
    uid?: string;
    gender?: string;
    picture?: string;
    email?: string;
    emailVerified?: boolean;
    phoneNumber?: string;
    username?: string;
    name?: string;
    providers?: {
        id?: string;
        providerUserId?: string;
        name?: string;
    }[];
    birthdate?: string;
    zoneinfo?: string;
    locale?: string;
    sub?: string;
    createdFrom?: string;
    private cache;
    private oauthInstance;
    constructor(options: IUserOptions);
    checkLocalInfo(): Promise<void>;
    checkLocalInfoAsync(): Promise<void>;
    update(userInfo: authModels.UserProfile): Promise<void>;
    updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest): Promise<void>;
    updatePassword(newPassword: string, oldPassword: string): any;
    updateUsername(username: string): Promise<void>;
    refresh(params?: {
        version?: string;
        query?: any;
    }): Promise<IUserInfo>;
    getLocalUserInfo(key?: string): string | boolean | Record<string, any>;
    setLocalUserInfo(userInfo: any): void;
    private getLocalUserInfoAsync;
    private setUserInfo;
}
interface ILoginStateOptions extends IUserOptions {
    envId: string;
}
export declare class LoginState implements ILoginState {
    user: User;
    oauthLoginState: any;
    private oauthInstance;
    private cache;
    constructor(options: ILoginStateOptions);
    checkLocalState(): void;
    checkLocalStateAsync(): Promise<void>;
}
declare class Auth extends SbaseApi {
    constructor(config: ICloudbaseAuthConfig & {
        cache: ICloudbaseCache;
        request?: ICloudbaseRequest;
        runtime?: string;
    });
    bindPhoneNumber(params: authModels.BindPhoneRequest): Promise<any>;
    unbindProvider(params: authModels.UnbindProviderRequest): Promise<void>;
    bindEmail(params: authModels.BindEmailRequest): any;
    verify(params: authModels.VerifyRequest): Promise<authModels.VerifyResponse>;
    getVerification(params: authModels.GetVerificationRequest, options?: {
        withCaptcha: boolean;
    }): Promise<authModels.GetVerificationResponse>;
    get currentUser(): User;
    getCurrentUser(): Promise<(authModels.UserInfo & Partial<User>) | null>;
    signInAnonymouslyInWx({ useWxCloud, }?: {
        useWxCloud?: boolean;
    }): Promise<LoginState>;
    bindOpenId(): Promise<void>;
    signInWithUnionId(): Promise<LoginState>;
    signInWithSms({ verificationInfo, verificationCode, phoneNum, bindInfo, }: {
        verificationInfo?: {
            verification_id: string;
            is_user: boolean;
        };
        verificationCode?: string;
        phoneNum?: string;
        bindInfo?: any;
    }): Promise<LoginState>;
    signInWithEmail({ verificationInfo, verificationCode, bindInfo, email, }: {
        verificationInfo?: {
            verification_id: string;
            is_user: boolean;
        };
        verificationCode?: string;
        bindInfo?: any;
        email?: string;
    }): Promise<LoginState>;
    setCustomSignFunc(getTickFn: authModels.GetCustomSignTicketFn): void;
    signIn(params: authModels.SignInRequest): Promise<LoginState>;
    setPassword(params: authModels.SetPasswordRequest): Promise<void>;
    isUsernameRegistered(username: string): Promise<boolean>;
    hasLoginState(): LoginState | null;
    getLoginState(): Promise<LoginState>;
    getUserInfo(): Promise<(authModels.UserInfo & Partial<User>) | null>;
    getWedaUserInfo(): Promise<any>;
    updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest): Promise<void>;
    getAuthHeader(): {};
    bindWithProvider(params: authModels.BindWithProviderRequest): Promise<void>;
    queryUser(queryObj: authModels.QueryUserProfileRequest): Promise<authModels.QueryUserProfileResponse>;
    getAccessToken(): Promise<{
        accessToken: any;
        env: string;
    }>;
    grantProviderToken(params: authModels.GrantProviderTokenRequest): Promise<authModels.GrantProviderTokenResponse>;
    patchProviderToken(params: authModels.PatchProviderTokenRequest): Promise<authModels.PatchProviderTokenResponse>;
    signInWithProvider(params: authModels.SignInWithProviderRequest): Promise<LoginState>;
    signInWithWechat(params?: any): Promise<LoginState>;
    grantToken(params: authModels.GrantTokenRequest): Promise<LoginState>;
    genProviderRedirectUri(params: authModels.GenProviderRedirectUriRequest): Promise<authModels.GenProviderRedirectUriResponse>;
    resetPassword(params: authModels.ResetPasswordRequest): Promise<void>;
    deviceAuthorize(params: authModels.DeviceAuthorizeRequest): Promise<authModels.DeviceAuthorizeResponse>;
    sudo(params: authModels.SudoRequest): Promise<authModels.SudoResponse>;
    deleteMe(params: authModels.WithSudoRequest): Promise<authModels.UserProfile>;
    getProviders(): Promise<authModels.ProvidersResponse>;
    loginScope(): Promise<string>;
    loginGroups(): Promise<string[]>;
    onLoginStateChanged(callback: Function): Promise<void>;
    refreshTokenForce(params: {
        version?: string;
    }): Promise<Credentials>;
    getCredentials(): Promise<Credentials>;
    setCredentials(credentials: Credentials): Promise<void>;
    getProviderSubType(): Promise<ProviderSubType>;
    createCaptchaData(params: {
        state: string;
        redirect_uri?: string;
    }): Promise<any>;
    verifyCaptchaData(params: {
        token: string;
        key: string;
    }): Promise<any>;
    getMiniProgramQrCode(params: authModels.GetMiniProgramQrCodeRequest): Promise<authModels.GetMiniProgramQrCodeResponse>;
    getMiniProgramQrCodeStatus(params: authModels.GetMiniProgramQrCodeStatusRequest): Promise<authModels.GetMiniProgramQrCodeStatusResponse>;
    modifyPassword(params: authModels.ModifyUserBasicInfoRequest): Promise<void>;
    modifyPasswordWithoutLogin(params: authModels.ModifyPasswordWithoutLoginRequest): Promise<void>;
    getUserBehaviorLog(params: authModels.GetUserBehaviorLog): Promise<authModels.GetUserBehaviorLogRes>;
    signInWithUsername({ verificationInfo, verificationCode, username: rawUsername, bindInfo, loginType, }: {
        verificationInfo?: {
            verification_id: string;
            is_user: boolean;
        };
        verificationCode?: string;
        username?: string;
        bindInfo?: any;
        loginType?: string;
    }): Promise<LoginState>;
    createLoginState(params?: {
        version?: string;
        query?: any;
    }, options?: {
        asyncRefreshUser?: boolean;
        userInfo?: any;
    }): Promise<LoginState>;
    setAccessKey(): Promise<void>;
}
type TInitAuthOptions = Pick<ICloudbaseAuthConfig, 'region' | 'persistence' | 'i18n' | 'accessKey' | 'useWxCloud'> & Partial<AuthOptions> & {
    detectSessionInUrl?: boolean;
};
export declare function generateAuthInstance(config: TInitAuthOptions, options?: {
    clientId: ICloudbaseConfig['clientId'];
    env: ICloudbaseConfig['env'];
    apiOrigin: string;
    cache?: ICloudbaseCache;
    platform?: ICloudbase['platform'];
    app?: ICloudbase;
    debug?: ICloudbaseAuthConfig['debug'];
    detectSessionInUrl?: ICloudbaseAuthConfig['detectSessionInUrl'];
}): {
    authInstance: Auth;
    oauthInstance: any;
};
export { UserInfo, Auth };
export declare function registerAuth(app: Pick<ICloudbase, 'registerComponent'>): void;
