import type { ICloudbase, ICloudbaseConfig, ICloudbasePlatformInfo } from '@cloudbase/types'
import type { ICloudbaseCache } from '@cloudbase/types/cache'
import type { ICloudbaseRequest } from '@cloudbase/types/request'
import type { ICloudbaseAuthConfig, IUser, IUserInfo, ILoginState } from '@cloudbase/types/auth'
import type { ICloudbaseComponent } from '@cloudbase/types/component'
import type { GrantProviderTokenResponse, ProviderSubType } from '@cloudbase/oauth/dist/cjs/auth/models'
import type { authModels, AuthOptions, Credentials } from '@cloudbase/oauth'
import {
  CloudbaseOAuth,
  AUTH_API_PREFIX,
  LOGIN_STATE_CHANGED_TYPE,
  EVENTS,
  AUTH_STATE_CHANGED_TYPE,
  OAUTH_TYPE,
} from '@cloudbase/oauth'
import { useAuthAdapter } from './adapter'
import {
  printWarn,
  throwError,
  ERRORS,
  COMMUNITY_SITE_URL,
  catchErrorsDecorator,
  CloudbaseEventEmitter,
  CloudbaseCache,
  adapterForWxMp,
  useDefaultAdapter,
} from './utilities'
import { SbaseApi } from './sbaseApi'

export type {
  SignInRes,
  GetUserRes,
  CommonRes,
  SignInWithOtpRes,
  SignInOAuthRes,
  GetClaimsRes,
  ResetPasswordForEmailRes,
  GetUserIdentitiesRes,
  LinkIdentityRes,
  ReauthenticateRes,
  ResendRes,
  UpdateUserWithVerificationRes,
  OnAuthStateChangeCallback,
  SignInWithPasswordReq,
  SignInWithIdTokenReq,
  SignInWithOAuthReq,
  VerifyOAuthReq,
  VerifyOtpReq,
  LinkIdentityReq,
  UnlinkIdentityReq,
  UpdateUserReq,
  SignInWithOtpReq,
  ResetPasswordForOldReq,
  ResendReq,
  SetSessionReq,
  DeleteMeReq,
  SignUpRes,
} from './type'

declare const cloudbase: ICloudbase
declare const wx: any

const COMPONENT_NAME = 'auth'

interface UserInfo {
  uid?: string
  gender?: string
  picture?: string
  email?: string
  email_verified?: boolean
  phone_number?: string
  username?: string
  name?: string
  birthdate?: string
  zoneinfo?: string
  locale?: string
  sub?: string
  created_from?: string
}


const onCredentialsError = eventBus => (params) => {
  eventBus.fire(EVENTS.LOGIN_STATE_CHANGED, { ...params, eventType: LOGIN_STATE_CHANGED_TYPE.CREDENTIALS_ERROR })
}

interface IUserOptions {
  cache: ICloudbaseCache
  oauthInstance: CloudbaseOAuth
}

export class User implements IUser {
  public uid?: string
  public gender?: string
  public picture?: string
  public email?: string
  public emailVerified?: boolean
  public phoneNumber?: string
  public username?: string // 用户名称，长度 5-24 位，支持字符中英文、数字、特殊字符（仅支持_-），不支持中文
  public name?: string
  public providers?: {
    id?: string
    providerUserId?: string
    name?: string
  }[]
  public birthdate?: string
  public zoneinfo?: string
  public locale?: string
  public sub?: string
  public createdFrom?: string

  private cache: ICloudbaseCache
  private oauthInstance: CloudbaseOAuth // CloudbaseOAuth 类型

  constructor(options: IUserOptions) {
    const { cache, oauthInstance } = options
    this.cache = cache
    this.oauthInstance = oauthInstance

    this.setUserInfo()
  }
  /**
   * 获取本地用户信息-同步
   */
  public async checkLocalInfo() {
    this.uid = this.getLocalUserInfo('uid') as string
    this.gender = this.getLocalUserInfo('gender') as string
    this.picture = this.getLocalUserInfo('picture') as string
    this.email = this.getLocalUserInfo('email') as string
    this.emailVerified = this.getLocalUserInfo('email_verified') as boolean
    this.phoneNumber = this.getLocalUserInfo('phone_number') as string
    this.username = this.getLocalUserInfo('username') as string
    this.name = this.getLocalUserInfo('name') as string
    this.birthdate = this.getLocalUserInfo('birthdate') as string
    this.zoneinfo = this.getLocalUserInfo('zoneinfo') as string
    this.locale = this.getLocalUserInfo('locale') as string
    this.sub = this.getLocalUserInfo('sub') as string
    this.createdFrom = this.getLocalUserInfo('created_from') as string
    this.providers = this.getLocalUserInfo('providers') as any
  }
  /**
   * 获取本地用户信息-异步
   */
  public async checkLocalInfoAsync() {
    this.uid = await this.getLocalUserInfoAsync('uid')
    this.gender = await this.getLocalUserInfoAsync('gender')
    this.picture = this.getLocalUserInfo('picture') as string
    this.email = await this.getLocalUserInfoAsync('email')
    this.emailVerified = this.getLocalUserInfo('email_verified') as boolean
    this.phoneNumber = this.getLocalUserInfo('phone_number') as string
    this.username = await this.getLocalUserInfoAsync('username')
    this.name = this.getLocalUserInfo('name') as string
    this.birthdate = this.getLocalUserInfo('birthdate') as string
    this.zoneinfo = this.getLocalUserInfo('zoneinfo') as string
    this.locale = this.getLocalUserInfo('locale') as string
    this.sub = this.getLocalUserInfo('sub') as string
    this.createdFrom = this.getLocalUserInfo('created_from') as string
    this.providers = this.getLocalUserInfo('providers') as any
  }

  /**
   * 更新用户信息
   * @param userInfo
   */
  @catchErrorsDecorator({
    title: '更新用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.update() 的语法或参数是否正确',
      '  2 - 用户信息中是否包含非法值',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async update(userInfo: authModels.UserProfile): Promise<void> {
    // const { name, gender, avatarUrl, province, country, city } = userInfo
    const newUserInfo = await this.oauthInstance.authApi.setUserProfile({ ...userInfo })

    this.setLocalUserInfo(newUserInfo)
  }

  public async updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest): Promise<void> {
    await this.oauthInstance.authApi.updateUserBasicInfo({ ...params })
    await this.refresh()
  }

  /**
   * 更新密码
   * @param newPassword
   * @param oldPassword
   */
  @catchErrorsDecorator({
    title: '更新密码失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.updatePassword() 的语法或参数是否正确',
      '  3 - 新密码中是否包含非法字符',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public updatePassword(newPassword: string, oldPassword: string) {
    return this.oauthInstance.authApi.updatePasswordByOld({
      old_password: oldPassword,
      new_password: newPassword,
    })
  }

  /**
   * 更新用户名
   * @param username
   */
  @catchErrorsDecorator({
    title: '更新用户名失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.updateUsername() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了用户名密码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public updateUsername(username: string) {
    if (typeof username !== 'string') {
      throwError(ERRORS.INVALID_PARAMS, 'username must be a string')
    }

    return this.update({
      username,
    })
  }

  /**
   * 刷新本地用户信息。当用户在其他客户端更新用户信息之后，可以调用此接口同步更新之后的信息。
   */
  @catchErrorsDecorator({
    title: '刷新本地用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.refresh() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async refresh(params?: { version?: string; query?: any }): Promise<IUserInfo> {
    const newUserInfo = await this.oauthInstance.authApi.getUserInfo(params)
    if ((newUserInfo as any).code === 'INVALID_ACCESS_TOKEN') {
      this.setLocalUserInfo({})
      throw newUserInfo
    }
    this.setLocalUserInfo(newUserInfo)
    return newUserInfo
  }

  public getLocalUserInfo(key?: string): string | boolean | Record<string, any> {
    const { userInfoKey } = this.cache.keys
    const userInfo = this.cache.getStore(userInfoKey)

    if (!key) return userInfo || {}

    return userInfo[key]
  }

  public setLocalUserInfo(userInfo: any) {
    const { userInfoKey } = this.cache.keys
    this.cache.setStore(userInfoKey, userInfo)
    this.setUserInfo()
  }

  private async getLocalUserInfoAsync(key: string): Promise<string> {
    const { userInfoKey } = this.cache.keys
    const userInfo = await this.cache.getStoreAsync(userInfoKey)
    return userInfo[key]
  }

  private setUserInfo() {
    const { userInfoKey } = this.cache.keys
    const userInfo = this.cache.getStore(userInfoKey)
    ;[
      'uid',
      'email',
      'name',
      'gender',
      'picture',
      'email_verified',
      'phone_number',
      'birthdate',
      'zoneinfo',
      'locale',
      'sub',
      'created_from',
      'providers',
      'username',
      'created_at',
    ].forEach((infoKey) => {
      this[infoKey] = userInfo[infoKey]
    })
  }
}
interface ILoginStateOptions extends IUserOptions {
  envId: string
}
export class LoginState implements ILoginState {
  public user: User
  public oauthLoginState: any

  private oauthInstance: CloudbaseOAuth
  private cache: ICloudbaseCache

  constructor(options: ILoginStateOptions) {
    const { envId, cache, oauthInstance } = options
    if (!envId) {
      throwError(ERRORS.INVALID_PARAMS, 'envId is not defined')
    }
    this.cache = cache
    this.oauthInstance = oauthInstance

    this.user = new User({
      cache: this.cache,
      oauthInstance,
    })
  }

  public checkLocalState() {
    this.oauthLoginState = this.oauthInstance?.authApi.hasLoginStateSync()
    this.user.checkLocalInfo()
  }

  public async checkLocalStateAsync() {
    await this.oauthInstance?.authApi.getLoginState()
    await this.user.checkLocalInfoAsync()
  }
}

class Auth extends SbaseApi {
  constructor(config: ICloudbaseAuthConfig & {
    cache: ICloudbaseCache
    request?: ICloudbaseRequest
    runtime?: string
  },) {
    super(config)
    this.setAccessKey()
  }

  /**
   * 绑定手机号
   * @param phoneNumber
   * @param phoneCode
   */
  @catchErrorsDecorator({
    title: '绑定手机号失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindPhoneNumber() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了短信验证码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async bindPhoneNumber(params: authModels.BindPhoneRequest) {
    return this.oauthInstance.authApi.editContact(params)
  }

  /**
   * 解绑三方绑定
   * @param loginType
   */
  @catchErrorsDecorator({
    title: '解除三方绑定失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().unbindProvider() 的语法或参数是否正确',
      '  2 - 当前账户是否已经与此登录方式解绑',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async unbindProvider(params: authModels.UnbindProviderRequest): Promise<void> {
    return this.oauthInstance.authApi.unbindProvider(params)
  }

  /**
   * 更新邮箱地址
   * @param email
   * @param sudo_token
   * @param verification_token
   */
  @catchErrorsDecorator({
    title: '绑定邮箱地址失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindEmail() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了邮箱密码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public bindEmail(params: authModels.BindEmailRequest) {
    return this.oauthInstance.authApi.editContact(params)
  }

  /**
   * verify
   * @param {authModels.VerifyRequest} params
   * @returns {Promise<authModels.VerifyResponse>}
   * @memberof User
   */
  @catchErrorsDecorator({
    title: '验证码验证失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().verify() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了手机验证码/邮箱登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async verify(params: authModels.VerifyRequest): Promise<authModels.VerifyResponse> {
    return this.oauthInstance.authApi.verify(params)
  }

  /**
   * 获取验证码
   * @param {authModels.GetVerificationRequest} params
   * @returns {Promise<authModels.GetVerificationResponse>}
   * @memberof User
   */
  @catchErrorsDecorator({
    title: '获取验证码失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getVerification() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了手机验证码/邮箱登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getVerification(
    params: authModels.GetVerificationRequest,
    options?: { withCaptcha: boolean },
  ): Promise<authModels.GetVerificationResponse> {
    return this.oauthInstance.authApi.getVerification(params, options)
  }

  /**
   * 获取当前登录的用户信息-同步
   */
  get currentUser() {
    if (this.cache.mode === 'async') {
      // async storage的平台调用此API提示
      printWarn(
        ERRORS.INVALID_OPERATION,
        'current platform\'s storage is asynchronous, please use getCurrentUser instead',
      )
      return
    }

    const loginState = this.hasLoginState()

    if (loginState) {
      return loginState.user || null
    }
    return null
  }

  /**
   * 获取当前登录的用户信息-异步
   */
  @catchErrorsDecorator({
    title: '获取用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getCurrentUser() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getCurrentUser(): Promise<(authModels.UserInfo & Partial<User>) | null> {
    const loginState = await this.getLoginState()
    if (loginState) {
      const userInfo = loginState.user.getLocalUserInfo() as authModels.UserInfo
      await loginState.user.checkLocalInfoAsync()
      return { ...loginState.user, ...userInfo }
    }
    return null
  }

  // /**
  //  * 匿名登录
  //  * @returns {Promise<LoginState>}
  //  * @memberof Auth
  //  */
  // @catchErrorsDecorator({
  //   title: '匿名登录失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 当前环境是否开启了匿名登录',
  //     '  2 - 调用 auth().signInAnonymously() 的语法或参数是否正确',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signInAnonymously(data: {
  //   provider_token?: string
  // } = {},): Promise<LoginState> {
  // await this.oauthInstance.authApi.signInAnonymously(data)
  // return this.createLoginState()
  // }

  /**
   * 匿名登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序匿名登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了匿名登录',
      '  2 - 调用 auth().signInAnonymouslyInWx() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInAnonymouslyInWx({
    useWxCloud,
  }: {
    useWxCloud?: boolean
  } = {}): Promise<LoginState> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    const wxInfo = wx.getAccountInfoSync().miniProgram

    const mainFunc = async (code) => {
      let result: GrantProviderTokenResponse | undefined = undefined
      let credentials: Credentials | undefined = undefined

      try {
        result = await this.oauthInstance.authApi.grantProviderToken(
          {
            provider_id: wxInfo?.appId,
            provider_code: code,
            provider_params: {
              provider_code_type: 'open_id',
              appid: wxInfo?.appId,
            },
          },
          useWxCloud,
        )

        if ((result as any)?.error_code || !result.provider_token) {
          throw result
        }

        credentials = await this.oauthInstance.authApi.signInAnonymously(
          { provider_token: result.provider_token },
          useWxCloud,
        )

        if ((credentials as any)?.error_code) {
          throw credentials
        }
      } catch (error) {
        throw error
      }
    }

    await new Promise((resolve, reject) => {
      wx.login({
        success: async (res: { code: string }) => {
          try {
            await mainFunc(res.code)
            resolve(true)
          } catch (error) {
            reject(error)
          }
        },
        fail: (res: any) => {
          const error = new Error(res?.errMsg)
          ;(error as any).code = res?.errno
          reject(error)
        },
      })
    })

    return this.createLoginState(undefined, { asyncRefreshUser: true })
  }

  /**
   * 小程序绑定OpenID
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序绑定OpenID失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序openId静默登录',
      '  2 - 调用 auth().bindOpenId() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async bindOpenId(): Promise<void> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    const wxInfo = wx.getAccountInfoSync().miniProgram

    const mainFunc = async (code) => {
      let result: GrantProviderTokenResponse | undefined = undefined

      try {
        result = await this.oauthInstance.authApi.grantProviderToken({
          provider_id: wxInfo?.appId,
          provider_code: code,
          provider_params: {
            provider_code_type: 'open_id',
            appid: wxInfo?.appId,
          },
        })

        if ((result as any)?.error_code || !result.provider_token) {
          throw result
        }

        await this.oauthInstance.authApi.bindWithProvider({ provider_token: result.provider_token })
      } catch (error) {
        throw error
      }
    }

    await new Promise((resolve, reject) => {
      wx.login({
        success: async (res: { code: string }) => {
          try {
            await mainFunc(res.code)
            resolve(true)
          } catch (error) {
            reject(error)
          }
        },
        fail: (res: any) => {
          const error = new Error(res?.errMsg)
          ;(error as any).code = res?.errno
          reject(error)
        },
      })
    })

    return
  }

  /**
   * 小程序openId静默登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  // @catchErrorsDecorator({
  //   title: '小程序openId静默登录失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 当前环境是否开启了小程序openId静默登录',
  //     '  2 - 调用 auth().signInWithOpenId() 的语法或参数是否正确',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signInWithOpenId({ useWxCloud = true } = {}): Promise<LoginState> {
  //   if (!adapterForWxMp.isMatch()) {
  //     throw Error('wx api undefined')
  //   }
  //   const wxInfo = wx.getAccountInfoSync().miniProgram

  //   const mainFunc = async (code) => {
  //     let result: GrantProviderTokenResponse | undefined = undefined
  //     let credentials: Credentials | undefined = undefined

  //     try {
  //       result = await this.oauthInstance.authApi.grantProviderToken(
  //         {
  //           provider_id: wxInfo?.appId,
  //           provider_code: code,
  //           provider_params: {
  //             provider_code_type: 'open_id',
  //             appid: wxInfo?.appId,
  //           },
  //         },
  //         useWxCloud,
  //       )

  //       if ((result as any)?.error_code || !result.provider_token) {
  //         throw result
  //       }

  //       credentials = await this.oauthInstance.authApi.signInWithProvider(
  //         { provider_token: result.provider_token },
  //         useWxCloud,
  //       )

  //       if ((credentials as any)?.error_code) {
  //         throw credentials
  //       }
  //     } catch (error) {
  //       throw error
  //     }
  //     await this.oauthInstance.oauth2client.setCredentials(credentials as Credentials)
  //   }

  //   await new Promise((resolve, reject) => {
  //     wx.login({
  //       success: async (res: { code: string }) => {
  //         try {
  //           await mainFunc(res.code)
  //           resolve(true)
  //         } catch (error) {
  //           reject(error)
  //         }
  //       },
  //       fail: (res: any) => {
  //         const error = new Error(res?.errMsg)
  //         ;(error as any).code = res?.errno
  //         reject(error)
  //       },
  //     })
  //   })

  //   return this.createLoginState()
  // }

  /**
   * 小程序unionId静默登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序unionId静默登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序unionId静默登录',
      '  2 - 调用 auth().signInWithUnionId() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithUnionId(): Promise<LoginState> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    try {
      await new Promise((resolve, reject) => {
        const wxInfo = wx.getAccountInfoSync().miniProgram
        wx.login({
          success: async (res: { code: string }) => {
            const providerId = wxInfo?.appId
            try {
              const result = await this.oauthInstance.authApi.grantProviderToken({
                provider_code: res.code,
                provider_id: providerId,
                provider_params: {
                  provider_code_type: 'union_id',
                  appid: wxInfo?.appId,
                },
              })

              const { provider_token: providerToken } = result

              if (!providerToken) {
                reject(result)
                return
              }

              const signInRes = await this.oauthInstance.authApi.signInWithProvider({
                provider_id: providerId,
                provider_token: providerToken,
              })

              if ((signInRes as any)?.error_code) {
                reject(signInRes)
                return
              }
              resolve(true)
            } catch (error) {
              reject(error)
            }
          },
          fail: (res: any) => {
            const error = new Error(res?.errMsg)
            ;(error as any).code = res?.errno
            reject(error)
          },
        })
      })
    } catch (error) {
      throw error
    }

    return this.createLoginState()
  }

  /**
   * 小程序手机号授权登录，目前只支持全托管手机号授权登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  // @catchErrorsDecorator({
  //   title: '小程序手机号授权登录失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 当前环境是否开启了小程序手机号授权登录',
  //     '  2 - 调用 auth().signInWithPhoneAuth() 的语法或参数是否正确',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signInWithPhoneAuth({ phoneCode = '' }): Promise<LoginState> {
  //   if (!adapterForWxMp.isMatch()) {
  //     throw Error('wx api undefined')
  //   }
  //   const wxInfo = wx.getAccountInfoSync().miniProgram
  //   const providerInfo = {
  //     provider_params: { provider_code_type: 'phone' },
  //     provider_id: wxInfo.appId,
  //   }

  //   const { code } = await wx.login()
  //   ;(providerInfo as any).provider_code = code

  //   try {
  //     let providerToken = await this.oauthInstance.authApi.grantProviderToken(providerInfo)
  //     if (providerToken.error_code) {
  //       throw providerToken
  //     }

  //     providerToken = await this.oauthInstance.authApi.patchProviderToken({
  //       provider_token: providerToken.provider_token,
  //       provider_id: wxInfo.appId,
  //       provider_params: {
  //         code: phoneCode,
  //         provider_code_type: 'phone',
  //       },
  //     })
  //     if (providerToken.error_code) {
  //       throw providerToken
  //     }

  //     const signInRes = await this.oauthInstance.authApi.signInWithProvider({
  //       provider_token: providerToken.provider_token,
  //     })

  //     if ((signInRes as any)?.error_code) {
  //       throw signInRes
  //     }
  //   } catch (error) {
  //     throw error
  //   }

  //   return this.createLoginState()
  // }

  /**
   * 小程序短信验证码登陆
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '短信验证码登陆',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序短信验证码登陆',
      '  2 - 调用 auth().signInWithSms() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithSms({
    verificationInfo = { verification_id: '', is_user: false },
    verificationCode = '',
    phoneNum = '',
    bindInfo = undefined,
  }): Promise<LoginState> {
    try {
      return this.signInWithUsername({
        verificationInfo,
        verificationCode,
        bindInfo,
        username: phoneNum,
        loginType: 'sms',
      })
    } catch (error) {
      throw error
    }
  }

  /**
   * 邮箱验证码登陆
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '邮箱验证码登陆',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了邮箱登陆',
      '  2 - 调用 auth().signInWithEmail() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithEmail({
    verificationInfo = { verification_id: '', is_user: false },
    verificationCode = '',
    bindInfo = undefined,
    email = '',
  }): Promise<LoginState> {
    try {
      return this.signInWithUsername({
        verificationInfo,
        verificationCode,
        bindInfo,
        username: email,
        loginType: 'email',
      })
    } catch (error) {
      throw error
    }
  }

  /**
   * 设置获取自定义登录 ticket 函数
   * @param {authModels.GetCustomSignTicketFn} getTickFn
   * @memberof Auth
   */
  public setCustomSignFunc(getTickFn: authModels.GetCustomSignTicketFn): void {
    this.oauthInstance.authApi.setCustomSignFunc(getTickFn)
  }

  /**
   *
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  // @catchErrorsDecorator({
  //   title: '自定义登录失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 当前环境是否开启了自定义登录',
  //     '  2 - 调用 auth().signInWithCustomTicket() 的语法或参数是否正确',
  //     '  3 - ticket 是否归属于当前环境',
  //     '  4 - 创建 ticket 的自定义登录私钥是否过期',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signInWithCustomTicket(): Promise<LoginState> {
  //   await this.oauthInstance.authApi.signInWithCustomTicket()
  //   return this.createLoginState()
  // }

  /**
   *
   * @param {authModels.SignInRequest} params
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  public async signIn(params: authModels.SignInRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.signIn(params)
    return this.createLoginState(params)
  }

  // /**
  //  *
  //  * @param {authModels.SignUpRequest} params
  //  * @returns {Promise<LoginState>}
  //  * @memberof Auth
  //  */
  // @catchErrorsDecorator({
  //   title: '注册失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 当前环境是否开启了指定登录方式',
  //     '  2 - 调用 auth().signUp() 的语法或参数是否正确',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signUp(params: authModels.SignUpRequest): Promise<any> {
  //   await this.oauthInstance.authApi.signUp(params)
  //   return this.createLoginState()
  // }

  /**
   * 设置密码
   * @param {authModels.SetPasswordRequest} params
   * @returns {Promise<void>}
   * @memberof Auth
   */
  public async setPassword(params: authModels.SetPasswordRequest): Promise<void> {
    return this.oauthInstance.authApi.setPassword(params)
  }

  /**
   * 检测用户名是否已经占用
   * @param username
   */
  @catchErrorsDecorator({
    title: '获取用户是否被占用失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().isUsernameRegistered() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async isUsernameRegistered(username: string): Promise<boolean> {
    if (typeof username !== 'string') {
      throwError(ERRORS.INVALID_PARAMS, 'username must be a string')
    }

    const { exist } = await this.oauthInstance.authApi.checkIfUserExist({ username })
    return exist
  }

  /**
   * 登出
   */
  // @catchErrorsDecorator({
  //   title: '用户登出失败',
  //   messages: [
  //     '请确认以下各项：',
  //     '  1 - 调用 auth().signOut() 的语法或参数是否正确',
  //     '  2 - 当前用户是否为匿名登录（匿名登录不支持signOut）',
  //     `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
  //   ],
  // })
  // public async signOut(params?: authModels.SignoutRequest): Promise<void | authModels.SignoutReponse> {
  //   const { userInfoKey } = this.cache.keys
  //   const res = await this.oauthInstance.authApi.signOut(params)
  //   await this.cache.removeStoreAsync(userInfoKey)

  //   eventBus.fire(EVENTS.LOGIN_STATE_CHANGED, { eventType: LOGIN_STATE_CHANGED_TYPE.SIGN_OUT })

  //   eventBus.fire(EVENTS.AUTH_STATE_CHANGED, { event: AUTH_STATE_CHANGED_TYPE.SIGNED_OUT })
  //   return res
  // }

  /**
   * 获取本地登录态-同步
   */
  public hasLoginState(): LoginState | null {
    if (this.cache.mode === 'async') {
      // async storage的平台调用此API提示
      printWarn(
        ERRORS.INVALID_OPERATION,
        'current platform\'s storage is asynchronous, please use getLoginState insteed',
      )
      return
    }

    const oauthLoginState = this.oauthInstance?.authApi.hasLoginStateSync()
    if (oauthLoginState) {
      const loginState = new LoginState({
        envId: this.config.env,
        cache: this.cache,
        oauthInstance: this.oauthInstance,
      })
      return loginState
    }
    return null
  }

  /**
   * 获取本地登录态-异步
   * 此API为兼容异步storage的平台
   */
  @catchErrorsDecorator({
    title: '获取本地登录态失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getLoginState() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getLoginState() {
    let oauthLoginState = null

    try {
      oauthLoginState = await this.oauthInstance.authApi.getLoginState()
    } catch (error) {
      return null
    }

    if (oauthLoginState) {
      const loginState = new LoginState({
        envId: this.config.env,
        cache: this.cache,
        oauthInstance: this.oauthInstance,
      })
      return loginState
    }

    return null
  }

  @catchErrorsDecorator({
    title: '获取用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 是否已登录',
      '  2 - 调用 auth().getUserInfo() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getUserInfo(): Promise<(authModels.UserInfo & Partial<User>) | null> {
    return this.getCurrentUser()
  }

  @catchErrorsDecorator({
    title: '获取微搭插件用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 是否已登录',
      '  2 - 调用 auth().getWedaUserInfo() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getWedaUserInfo(): Promise<any> {
    return this.oauthInstance.authApi.getWedaUserInfo()
  }

  public async updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest) {
    const loginState = await this.getLoginState()
    if (loginState) {
      await (loginState.user as User).updateUserBasicInfo(params)
    }
    return
  }

  /**
   * getAuthHeader 兼容处理
   * 返回空对象
   */
  public getAuthHeader(): {} {
    console.error('Auth.getAuthHeader API 已废弃')
    return {}
  }

  /**
   * 为已有账户绑第三方账户
   * @param {authModels.BindWithProviderRequest} params
   * @returns {Promise<void>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '绑定第三方登录方式失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindWithProvider() 的语法或参数是否正确',
      '  2 - 此账户是否已经绑定此第三方',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async bindWithProvider(params: authModels.BindWithProviderRequest): Promise<void> {
    return this.oauthInstance.authApi.bindWithProvider(params)
  }

  /**
   * 查询用户
   * @param {authModels.QueryUserProfileRequest} appended_params
   * @returns {Promise<authModels.UserProfile>}
   * @memberof Auth
   */
  public async queryUser(queryObj: authModels.QueryUserProfileRequest): Promise<authModels.QueryUserProfileResponse> {
    return this.oauthInstance.authApi.queryUserProfile(queryObj)
  }

  public async getAccessToken() {
    const oauthAccessTokenRes = await this.oauthInstance.oauth2client.getAccessToken()
    return {
      accessToken: oauthAccessTokenRes,
      env: this.config.env,
    }
  }

  public async grantProviderToken(params: authModels.GrantProviderTokenRequest,): Promise<authModels.GrantProviderTokenResponse> {
    return this.oauthInstance.authApi.grantProviderToken(params)
  }

  public async patchProviderToken(params: authModels.PatchProviderTokenRequest,): Promise<authModels.PatchProviderTokenResponse> {
    return this.oauthInstance.authApi.patchProviderToken(params)
  }

  public async signInWithProvider(params: authModels.SignInWithProviderRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.signInWithProvider(params)
    return this.createLoginState(params)
  }

  public async signInWithWechat(params: any = {}) {
    await this.oauthInstance.authApi.signInWithWechat(params)
    return this.createLoginState(params)
  }

  public async grantToken(params: authModels.GrantTokenRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.grantToken(params)
    return this.createLoginState()
  }

  public async genProviderRedirectUri(params: authModels.GenProviderRedirectUriRequest,): Promise<authModels.GenProviderRedirectUriResponse> {
    return this.oauthInstance.authApi.genProviderRedirectUri(params)
  }

  public async resetPassword(params: authModels.ResetPasswordRequest): Promise<void> {
    return this.oauthInstance.authApi.resetPassword(params)
  }

  public async deviceAuthorize(params: authModels.DeviceAuthorizeRequest): Promise<authModels.DeviceAuthorizeResponse> {
    return this.oauthInstance.authApi.deviceAuthorize(params)
  }

  public async sudo(params: authModels.SudoRequest): Promise<authModels.SudoResponse> {
    return this.oauthInstance.authApi.sudo(params)
  }

  public async deleteMe(params: authModels.WithSudoRequest): Promise<authModels.UserProfile> {
    return this.oauthInstance.authApi.deleteMe(params)
  }

  public async getProviders(): Promise<authModels.ProvidersResponse> {
    return this.oauthInstance.authApi.getProviders()
  }

  public async loginScope(): Promise<string> {
    return this.oauthInstance.authApi.loginScope()
  }

  public async loginGroups(): Promise<string[]> {
    return this.oauthInstance.authApi.loginGroups()
  }

  public async onLoginStateChanged(callback: Function) {
    this.config.eventBus?.on(EVENTS.LOGIN_STATE_CHANGED, async (params) => {
      // getLoginState会重复触发getCredentials，导致死循环，所以getCredentials出错不再出发getLoginState
      const loginState =        params?.data?.eventType !== LOGIN_STATE_CHANGED_TYPE.CREDENTIALS_ERROR ? await this.getLoginState() : {}
      callback.call(this, { ...params, ...loginState })
    })
    // 立刻执行一次回调
    const loginState = await this.getLoginState()
    callback.call(this, loginState)
  }

  /**
   * 强制刷新token
   * @param params
   * @returns
   */
  public async refreshTokenForce(params: { version?: string }): Promise<Credentials> {
    return this.oauthInstance.authApi.refreshTokenForce(params)
  }

  /**
   * 获取身份信息
   * @returns
   */
  public async getCredentials(): Promise<Credentials> {
    return this.oauthInstance.authApi.getCredentials()
  }
  /**
   * 写入身份信息
   */
  public async setCredentials(credentials: Credentials) {
    await this.oauthInstance.oauth2client.setCredentials(credentials)
  }

  @catchErrorsDecorator({
    title: '获取身份源类型',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getProviderSubType() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getProviderSubType(): Promise<ProviderSubType> {
    return this.oauthInstance.authApi.getProviderSubType()
  }

  public async createCaptchaData(params: { state: string; redirect_uri?: string }) {
    return this.oauthInstance.authApi.createCaptchaData(params)
  }

  public async verifyCaptchaData(params: { token: string; key: string }) {
    return this.oauthInstance.authApi.verifyCaptchaData(params)
  }

  public async getMiniProgramQrCode(params: authModels.GetMiniProgramQrCodeRequest,): Promise<authModels.GetMiniProgramQrCodeResponse> {
    return this.oauthInstance.authApi.getMiniProgramCode(params)
  }

  public async getMiniProgramQrCodeStatus(params: authModels.GetMiniProgramQrCodeStatusRequest,): Promise<authModels.GetMiniProgramQrCodeStatusResponse> {
    return this.oauthInstance.authApi.getMiniProgramQrCodeStatus(params)
  }

  public async modifyPassword(params: authModels.ModifyUserBasicInfoRequest): Promise<void> {
    return this.oauthInstance.authApi.modifyPassword(params)
  }

  public async modifyPasswordWithoutLogin(params: authModels.ModifyPasswordWithoutLoginRequest): Promise<void> {
    return this.oauthInstance.authApi.modifyPasswordWithoutLogin(params)
  }

  public async getUserBehaviorLog(params: authModels.GetUserBehaviorLog): Promise<authModels.GetUserBehaviorLogRes> {
    return this.oauthInstance.authApi.getUserBehaviorLog(params)
  }

  /**
   * sms/email 验证码登录/注册，逻辑一致收敛
   */
  public async signInWithUsername({
    verificationInfo = { verification_id: '', is_user: false },
    verificationCode = '',
    username: rawUsername = '',
    bindInfo = undefined,
    loginType = '',
  }): Promise<LoginState> {
    try {
      // 1. 验证验证码
      const verifyRes = await this.oauthInstance.authApi.verify({
        verification_id: verificationInfo.verification_id,
        verification_code: verificationCode,
      })

      if ((verifyRes as any)?.error_code) {
        throw verifyRes
      }

      // eslint-disable-next-line @typescript-eslint/naming-convention
      const { verification_token } = verifyRes

      // 手机登录参数
      let username = /^\+\d{1,3}\s+/.test(rawUsername) ? rawUsername : `+86 ${rawUsername}`
      let signUpParam: any = { phone_number: username }

      // 邮箱登录参数
      if (loginType === 'email') {
        username = rawUsername
        signUpParam = { email: username }
      }

      // 2. 根据是否已经是用户，分别走登录或注册逻辑
      if (verificationInfo.is_user) {
        // 私有化环境或者自定义应用走v1版本的老逻辑
        const signInRes = await this.oauthInstance.authApi.signIn({
          username,
          verification_token,
        })

        if ((signInRes as any)?.error_code) {
          throw signInRes
        }

        if (bindInfo) {
          const bindRes = await this.oauthInstance.authApi.bindWithProvider({
            provider_token: (bindInfo as any)?.providerToken,
          })

          if ((bindRes as any)?.error_code) {
            throw bindRes
          }
        }
      } else {
        // 自定义应用走signUp逻辑
        const signUpRes = await this.oauthInstance.authApi.signUp({
          ...signUpParam,
          verification_token,
          provider_token: (bindInfo as any)?.providerId,
        })

        if ((signUpRes as any)?.error_code) {
          throw signUpRes
        }
      }

      return this.createLoginState()
    } catch (error) {
      throw error
    }
  }

  async createLoginState(
    params?: { version?: string; query?: any },
    options?: { asyncRefreshUser?: boolean; userInfo?: any },
  ): Promise<LoginState> {
    const loginState = new LoginState({
      envId: this.config.env,
      cache: this.cache,
      oauthInstance: this.oauthInstance,
    })

    await loginState.checkLocalStateAsync()

    if (options?.userInfo) {
      loginState.user.setLocalUserInfo(options.userInfo)
    } else {
      if (options?.asyncRefreshUser) {
        loginState.user.refresh(params)
      } else {
        await loginState.user.refresh(params)
      }
    }

    this.config.eventBus?.fire(EVENTS.LOGIN_STATE_CHANGED, { eventType: LOGIN_STATE_CHANGED_TYPE.SIGN_IN })

    this.config.eventBus?.fire(EVENTS.AUTH_STATE_CHANGED, { event: AUTH_STATE_CHANGED_TYPE.SIGNED_IN })
    return loginState
  }

  async setAccessKey() {
    if (this.config.accessKey) {
      try {
        this.oauthInstance.oauth2client.setAccessKeyCredentials({
          access_token: this.config.accessKey,
          token_type: 'Bearer',
          scope: 'accessKey',
          expires_at: new Date(+new Date() + +new Date()),
          expires_in: +new Date() + +new Date(),
        })
      } catch (error) {
        console.warn('accessKey error: ', error)
      }
    }
  }
}

type TInitAuthOptions = Pick<ICloudbaseAuthConfig, 'region' | 'persistence' | 'i18n' | 'accessKey' | 'useWxCloud'> &
Partial<AuthOptions> & {
  detectSessionInUrl?: boolean
}

export function generateAuthInstance(
  config: TInitAuthOptions,
  options?: {
    clientId: ICloudbaseConfig['clientId']
    env: ICloudbaseConfig['env']
    apiOrigin: string
    cache?: ICloudbaseCache
    platform?: ICloudbase['platform']
    app?: ICloudbase
    debug?: ICloudbaseAuthConfig['debug']
    detectSessionInUrl?: ICloudbaseAuthConfig['detectSessionInUrl']
  },
) {
  const { region = 'ap-shanghai', i18n, accessKey, useWxCloud } = config
  const platform = options?.platform || (useDefaultAdapter.bind(options)() as ICloudbasePlatformInfo)
  const { runtime, adapter } = platform

  const { env, clientId, debug, cache, app: cloudbase } = options || {}
  let { apiOrigin } = options || {}
  if (!apiOrigin) {
    apiOrigin = `https://${env}.${region}.tcb-api.tencentcloudapi.com`
  }

  const commonOpts = {
    env,
    clientId,
    i18n,
    accessKey,
    useWxCloud,
    eventBus: new CloudbaseEventEmitter(),
  }

  const oauthInstance = new CloudbaseOAuth(useAuthAdapter({
    ...commonOpts,
    apiOrigin,
    apiPath: config?.apiPath || AUTH_API_PREFIX,
    // @todo 以下最好走adaptor处理，目前oauth模块没按adaptor接口设计
    storage: config?.storage,
    baseRequest: config?.baseRequest,
    request: config?.request,
    anonymousSignInFunc: config?.anonymousSignInFunc,
    captchaOptions: config?.captchaOptions,
    wxCloud: config?.wxCloud,
    adapter,
    onCredentialsError: onCredentialsError(commonOpts.eventBus),
    headers: { 'X-SDK-Version': `@cloudbase/js-sdk/${config.sdkVersion}`, ...(config.headers || {}) },
    detectSessionInUrl: config.detectSessionInUrl,
    debug,
  }),)

  const authInstance = new Auth({
    ...commonOpts,
    region,
    persistence: config.persistence,
    debug,
    cache:
      cache
      || new CloudbaseCache({
        persistence: config.persistence,
        keys: { userInfoKey: `user_info_${env}` },
        platformInfo: platform,
      }),
    runtime: runtime || 'web',
    _fromApp: cloudbase,
    oauthInstance,
  })

  // Initialize session with user info callback
  // This handles OAuth callback URL detection and creates login state atomically
  oauthInstance.initializeSession(async (data, error) => {
    if (!data) return

    if (data.type === OAUTH_TYPE.SIGN_IN) {
      if (error) {
        commonOpts.eventBus.fire(EVENTS.AUTH_STATE_CHANGED, {
          event: AUTH_STATE_CHANGED_TYPE.SIGNED_IN,
          info: { ...data, error },
        })
      } else if (data.user) {
        // 使用已获取的 user 信息创建 LoginState，复用 createLoginState 逻辑
        // 但跳过 refresh() 避免再次请求 API 导致死锁
        authInstance.createLoginState({}, { userInfo: data.user })
      }
    } else if (data.type === OAUTH_TYPE.BIND_IDENTITY) {
      commonOpts.eventBus.fire(EVENTS.AUTH_STATE_CHANGED, {
        event: AUTH_STATE_CHANGED_TYPE.BIND_IDENTITY,
        info: { ...data, error },
      })
    }
  })

  return { authInstance, oauthInstance }
}

const NAMESPACE = 'auth'

const component: ICloudbaseComponent = {
  name: COMPONENT_NAME,
  namespace: NAMESPACE,
  entity(config?: TInitAuthOptions) {
    const auth = function (config?: TInitAuthOptions) {
      if (this.authInstance && !config) {
        // printWarn(ERRORS.INVALID_OPERATION, 'every cloudbase instance should has only one auth object')
        return this.authInstance
      }

      config = config || {
        region: '',
        persistence: 'local',
        apiPath: AUTH_API_PREFIX,
      }
      const { adapter } = this.platform
      // 如不明确指定persistence则优先取各平台adapter首选，其次localStorage
      const newPersistence = config.persistence || adapter.primaryStorage
      if (newPersistence && newPersistence !== this.config.persistence) {
        this.updateConfig({ persistence: newPersistence })
      }

      const { authInstance, oauthInstance } = generateAuthInstance(
        {
          wxCloud: this.config.wxCloud,
          storage: this.config.storage,
          ...config,
          persistence: this.config.persistence,
          i18n: this.config.i18n,
          accessKey: this.config.accessKey,
          useWxCloud: this.config.useWxCloud,
          sdkVersion: this.version,
          detectSessionInUrl: this.config.auth?.detectSessionInUrl,
        },
        {
          env: this.config.env,
          clientId: this.config.clientId,
          apiOrigin: this.request.getBaseEndPoint(this.config.endPointMode || 'CLOUD_API'),
          platform: this.platform,
          cache: this.cache,
          app: this,
          debug: this.config.debug,
        },
      )

      this.oauthInstance = oauthInstance

      this.authInstance = authInstance

      return this.authInstance
    }

    const authProto = auth.call(this, config)
    Object.assign(auth, authProto)
    Object.setPrototypeOf(auth, Object.getPrototypeOf(authProto))
    this[NAMESPACE] = auth
    return auth
  },
}

try {
  // 尝试自动注册至全局变量cloudbase
  // 此行为只在浏览器环境下有效
  cloudbase.registerComponent(component)
} catch (e) {}

export { UserInfo, Auth }
/**
 * @api 手动注册至cloudbase app
 */
export function registerAuth(app: Pick<ICloudbase, 'registerComponent'>) {
  try {
    app.registerComponent(component)
  } catch (e) {
    console.warn(e)
  }
}
