import { constants, utils, helpers } from '@cloudbase/utilities'

import {
  ICloudbaseFileMetaDataRes,
  ICloudbaseFileInfo,
  ICloudbaseUploadFileParams,
  ICloudbaseUploadFileResult,
  ICloudbaseGetUploadMetadataParams,
  ICloudbaseDeleteFileParams,
  ICloudbaseDeleteFileResult,
  ICloudbaseGetTempFileURLResult,
  ICloudbaseGetTempFileURLParams,
  ICloudbaseDownloadFileResult,
  ICloudbaseDownloadFileParams,
  ICloudbaseCopyFileParams,
  ICloudbaseCopyFileResult,
} from '@cloudbase/types/storage'

enum EUploadMethod {
  put = 'put',
  post = 'post',
}

interface IUploadMetadata {
  url: string
  token: string
  authorization: string
  fileId: string
  cosFileId: string
  download_url?: string
}

const { getSdkName, ERRORS, COMMUNITY_SITE_URL } = constants
const { isArray, isString, isPalinObject, execCallback } = utils
const { catchErrorsDecorator } = helpers

export const COMPONENT_NAME = 'storage'

// function basename(path) {
//   const lastSlashIndex = path.lastIndexOf('/')
//   if (lastSlashIndex === -1) return path
//   return path.slice(lastSlashIndex + 1)
// }

const storageGateWay = {
  getUploadInfo: async (
    request,
    params: { path: string; headers?: Record<string, string> },
    customReqOpts: ICloudbaseUploadFileParams['customReqOpts'],
  ) => {
    let res = await request.gateWay(
      {
        path: 'storages',
        name: 'get-objects-upload-info',
        data: [
          {
            objectId: params.path,
            ...(params.headers ? { signedHeader: params.headers } : {}),
          },
        ],
      },
      customReqOpts,
    )
    const data = res.data?.[0] || {}

    res = {
      ...res,
      data: {
        ...(data.code ? { ...data } : {}),
        authorization: data.authorization,
        token: data.token,
        url: data.uploadUrl,
        fileId: data.cloudObjectId,
        cosFileId: data.cloudObjectMeta,
        download_url: data.downloadUrl,
      },
    }

    return res
  },
  getDownLoadInfo: async (
    request,
    params: { convertedFileList: Array<{ fileid: string }> },
    customReqOpts: ICloudbaseUploadFileParams['customReqOpts'],
  ) => {
    let res = await request.gateWay(
      {
        path: 'storages',
        name: 'get-objects-download-info',
        data: params.convertedFileList.map((v: any) => ({ cloudObjectId: v.fileid })),
      },
      customReqOpts,
    )
    res = {
      ...res,
      data: {
        download_list: res.data?.map(v => ({
          code: v.code || 'SUCCESS',
          message: v.message,
          fileid: v.cloudObjectId,
          download_url: v.downloadUrl,
          fileID: v.cloudObjectId,
          tempFileURL: v.downloadUrl,
        })),
      },
    }

    return res
  },
  delete: async (
    request,
    params: { fileList: Array<string> },
    customReqOpts: ICloudbaseUploadFileParams['customReqOpts'],
  ) => {
    let res = await request.gateWay(
      {
        path: 'storages',
        name: 'delete-objects',
        data: params.fileList.map(v => ({ cloudObjectId: v })),
      },
      customReqOpts,
    )
    res = {
      ...res,
      data: {
        delete_list: res.data?.map(v => ({
          code: v.code || 'SUCCESS',
          fileID: v.cloudObjectId,
          message: v.message,
        })),
      },
    }

    return res
  },
  copyFile: async (
    request,
    params: {
      convertedFileList: Array<{ src_path: string; dst_path: string; overwrite: boolean; remove_original: boolean }>
    },
    customReqOpts: ICloudbaseUploadFileParams['customReqOpts'],
  ) => {
    let res = await request.gateWay(
      {
        path: 'storages',
        name: 'copy-objects',
        data: params.convertedFileList.map((v: any) => ({
          srcPath: v.src_path,
          dstPath: v.dst_path,
          overwrite: v.overwrite,
          removeOriginal: v.remove_original,
        })),
      },
      customReqOpts,
    )
    res = {
      ...res,
      data: {
        copy_list: res.data?.map(v => ({
          code: v.code || 'SUCCESS',
          fileID: v.cloudObjectId,
          message: v.message,
        })),
      },
    }

    return res
  },
}

export interface ICloudbaseContext {
  config: any
  request: any
}

export class CloudbaseStorage {
  public isGateWay() {
    // @ts-ignore
    const { config } = this
    const endPointMode = config.endPointMode || 'CLOUD_API'

    return endPointMode === 'GATEWAY'
  }

  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'uploadFile',
    },
    title: '上传文件失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 uploadFile() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async uploadFile(
    params: Omit<ICloudbaseUploadFileParams, 'filePath'> & { filePath?: string },
    callback?: Function,
  ): Promise<ICloudbaseUploadFileResult> {
    const { cloudPath, filePath, onUploadProgress, method = 'put', headers = {}, fileContent } = params
    if (!isString(cloudPath) || (!filePath && !fileContent)) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.uploadFile] invalid params`,
      }),)
    }
    const uploadMethod =      { put: EUploadMethod.put, post: EUploadMethod.post }[method.toLocaleLowerCase()] || EUploadMethod.put

    // 调用 getUploadMetadata 获取上传元数据
    const metadataResult = await this.getUploadMetadata({
      cloudPath,
      method: uploadMethod,
      headers: uploadMethod === EUploadMethod.put ? headers : undefined,
      customReqOpts: params.customReqOpts,
    })

    const { data: metadata, requestId } = metadataResult
    const { url, authorization, token, fileId, cosFileId, download_url: downloadUrl } = metadata

    const commonParams = {
      url,
      file: filePath,
      name: cloudPath,
      onUploadProgress,
      fileContent,
      fileId,
      requestId,
    }

    const putParams = {
      ...commonParams,
      method: EUploadMethod.put,
      headers: {
        ...headers,
        authorization,
        'x-cos-meta-fileid': cosFileId,
        'x-cos-security-token': token,
      },
    }

    const postParams = {
      ...commonParams,
      method: EUploadMethod.post,
      data: {
        key: cloudPath,
        signature: authorization,
        'x-cos-meta-fileid': cosFileId,
        success_action_status: '201',
        'x-cos-security-token': token,
      },
    }

    const uploadConfig = {
      [EUploadMethod.put]: {
        params: putParams,
        isSuccess: (code: number) => code >= 200 && code < 300,
      },
      [EUploadMethod.post]: {
        params: postParams,
        isSuccess: (code: number) => code === 201,
      },
    }

    // @ts-ignore
    const res = await this.request.upload(uploadConfig[uploadMethod].params)

    if (uploadConfig[uploadMethod].isSuccess(res.statusCode)) {
      return execCallback(callback, null, {
        fileID: fileId,
        download_url: downloadUrl,
        requestId,
      })
    }
    return execCallback(
      callback,
      new Error(`[${getSdkName()}][${ERRORS.OPERATION_FAIL}][${COMPONENT_NAME}]:${res.data}`),
    )
  }
  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'getUploadMetadata',
    },
    title: '获取上传元信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 getUploadMetadata() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getUploadMetadata(
    params: ICloudbaseGetUploadMetadataParams & {
      method?: EUploadMethod
      headers?: Record<string, string>
    },
    callback?: Function,
  ): Promise<{ data: IUploadMetadata; requestId: string }> {
    const { cloudPath, method, headers } = params
    if (!isString(cloudPath)) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.getUploadMetadata] invalid cloudPath`,
      }),)
    }
    // @ts-ignore
    const { request } = this
    const action = 'storage.getUploadMetadata'

    try {
      let metaData: ICloudbaseFileMetaDataRes

      const metaDataParam: {
        path: string
        method?: EUploadMethod
        headers?: Record<string, string>
      } = { path: cloudPath }

      if (method) {
        metaDataParam.method = method
      }
      if (method === EUploadMethod.put && headers) {
        metaDataParam.headers = headers
      }

      if (this.isGateWay()) {
        metaData = await storageGateWay.getUploadInfo(request, metaDataParam, params.customReqOpts)
      } else {
        metaData = await request.send(action, metaDataParam, params.customReqOpts)
      }
      return execCallback(callback, null, metaData)
    } catch (err) {
      return execCallback(callback, err)
    }
  }
  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'deleteFile',
    },
    title: '删除文件失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 deleteFile() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async deleteFile(
    params: ICloudbaseDeleteFileParams,
    callback?: Function,
  ): Promise<ICloudbaseDeleteFileResult> {
    const { fileList } = params

    if (!fileList || !isArray(fileList) || fileList.length === 0) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.deleteFile] fileList must not be empty`,
      }),)
    }

    for (const fileId of fileList) {
      if (!fileId || !isString(fileId)) {
        throw new Error(JSON.stringify({
          code: ERRORS.INVALID_PARAMS,
          msg: `[${COMPONENT_NAME}.deleteFile] fileID must be string`,
        }),)
      }
    }

    const action = 'storage.batchDeleteFile'
    // @ts-ignore
    const { request } = this
    let res: any = {}

    if (this.isGateWay()) {
      res = await storageGateWay.delete(request, { fileList }, params.customReqOpts)
    } else {
      res = await request.send(
        action,
        {
          fileid_list: fileList,
        },
        params.customReqOpts,
      )
    }

    if (res.code) {
      return execCallback(callback, null, res)
    }
    const data = {
      fileList: res.data.delete_list,
      requestId: res.requestId,
    }
    return execCallback(callback, null, data)
  }
  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'getTempFileURL',
    },
    title: '获取文件下载链接',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 getTempFileURL() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getTempFileURL(
    params: ICloudbaseGetTempFileURLParams,
    callback?: Function,
  ): Promise<ICloudbaseGetTempFileURLResult> {
    const { fileList } = params

    if (!fileList || !isArray(fileList) || fileList.length === 0) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.getTempFileURL] fileList must not be empty`,
      }),)
    }

    const convertedFileList = []
    for (const file of fileList) {
      if (isPalinObject(file)) {
        if (!Object.prototype.hasOwnProperty.call(file, 'fileID')) {
          throw new Error(JSON.stringify({
            code: ERRORS.INVALID_PARAMS,
            msg: `[${COMPONENT_NAME}.getTempFileURL] file info must include fileID`,
          }),)
        }

        convertedFileList.push({
          fileid: (file as ICloudbaseFileInfo).fileID,
          max_age: (file as ICloudbaseFileInfo).maxAge || 7200,
        })
      } else if (isString(file)) {
        convertedFileList.push({
          fileid: file,
        })
      } else {
        throw new Error(JSON.stringify({
          code: ERRORS.INVALID_PARAMS,
          msg: `[${COMPONENT_NAME}.getTempFileURL] invalid fileList`,
        }),)
      }
    }

    const action = 'storage.batchGetDownloadUrl'
    // @ts-ignore
    const { request } = this
    let res: any = {}

    if (this.isGateWay()) {
      res = await storageGateWay.getDownLoadInfo(request, { convertedFileList }, params.customReqOpts)
    } else {
      res = await request.send(action, { file_list: convertedFileList }, params.customReqOpts)
    }

    if (res.code) {
      return execCallback(callback, null, res)
    }

    return execCallback(callback, null, {
      fileList: res.data.download_list,
      requestId: res.requestId,
    })
  }
  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'downloadFile',
    },
    title: '下载文件失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 downloadFile() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async downloadFile(
    params: ICloudbaseDownloadFileParams,
    callback?: Function,
  ): Promise<ICloudbaseDownloadFileResult> {
    const { fileID } = params
    if (!isString(fileID)) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.getTempFileURL] fileID must be string`,
      }),)
    }

    const tmpUrlRes = await this.getTempFileURL.call(this, {
      fileList: [
        {
          fileID,
          maxAge: 600,
        },
      ],
      customReqOpts: params.customReqOpts,
    })

    const res = tmpUrlRes.fileList[0]

    if (res.code !== 'SUCCESS') {
      return execCallback(callback, res)
    }
    // @ts-ignore
    const { request } = this

    const tmpUrl = encodeURI(res.download_url)

    const result = await request.download({ url: tmpUrl, tempFilePath: params.tempFilePath })
    return execCallback(callback, null, result)
  }
  @catchErrorsDecorator({
    customInfo: {
      className: 'Cloudbase',
      methodName: 'copyFile',
    },
    title: '批量复制文件',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 copyFile() 的语法或参数是否正确',
      '  2 - 当前域名是否在安全域名列表中：https://console.cloud.tencent.com/tcb/env/safety',
      '  3 - 云存储安全规则是否限制了当前登录状态访问',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async copyFile(params: ICloudbaseCopyFileParams, callback?: Function): Promise<ICloudbaseCopyFileResult> {
    const { fileList } = params

    if (!fileList || !isArray(fileList) || fileList.length === 0) {
      throw new Error(JSON.stringify({
        code: ERRORS.INVALID_PARAMS,
        msg: `[${COMPONENT_NAME}.copyFile] fileList must not be empty`,
      }),)
    }

    const convertedFileList = []

    for (const file of fileList) {
      const { srcPath, dstPath } = file
      if (!srcPath || !dstPath || typeof srcPath !== 'string' || typeof dstPath !== 'string') {
        throw new Error(JSON.stringify({
          code: ERRORS.INVALID_PARAMS,
          msg: `[${COMPONENT_NAME}.copyFile] srcPath and dstPath may not be empty`,
        }),)
      }
      if (srcPath === dstPath) {
        throw new Error(JSON.stringify({
          code: ERRORS.INVALID_PARAMS,
          msg: `[${COMPONENT_NAME}.copyFile] srcPath and dstPath can not be the same`,
        }),)
      }
      //   if (basename(srcPath) !== basename(dstPath)) {
      //     throw new Error(JSON.stringify({
      //       code: ERRORS.INVALID_PARAMS,
      //       msg: `[${COMPONENT_NAME}.copyFile] srcPath and dstPath file name must be the same`,
      //     }),)
      //   }
      convertedFileList.push({
        src_path: srcPath,
        dst_path: dstPath,
        overwrite: file.overwrite,
        remove_original: file.removeOriginal,
      })
    }

    // @ts-ignore
    const { request } = this
    let res: any = {}

    if (this.isGateWay()) {
      res = await storageGateWay.copyFile(request, { convertedFileList }, params.customReqOpts)
    } else {
      const action = 'storage.batchCopyFile'
      res = await request.send(action, { file_list: convertedFileList }, params.customReqOpts)
    }

    if (res.code) {
      return execCallback(callback, null, res)
    }

    return execCallback(callback, null, {
      fileList: res.data.copy_list,
      requestId: res.requestId,
    })
  }

  public async getFileInfo(params: ICloudbaseGetTempFileURLParams): Promise<{
    fileList: (Pick<ICloudbaseGetTempFileURLResult['fileList'][0], 'code' | 'fileID' | 'tempFileURL' | 'message'> & {
      fileName?: string
      cloudId?: ICloudbaseGetTempFileURLResult['fileList'][0]['fileID']
      contentType?: string
      mime?: string
      size?: number
      cacheControl?: string
      lastModified?: string
      etag?: string
    })[]
    requestId: string
  }> {
    const fileInfo = await this.getTempFileURL(params)

    if (fileInfo?.fileList && fileInfo?.fileList?.length > 0) {
      const fileList = await Promise.all(fileInfo.fileList.map(async (item: ICloudbaseGetTempFileURLResult['fileList'][0]) => {
        if (item.code !== 'SUCCESS') {
          return {
            code: item.code,
            fileID: item.fileID,
            tempFileURL: item.tempFileURL,
            message: item.message,
          }
        }

        try {
          // @ts-ignore
          const { request } = this
          const res = await request.fetch({ url: item.tempFileURL, method: 'HEAD' })
          let { header } = res

          if (Headers && header instanceof Headers) {
            header = Object.fromEntries(res.header.entries())
          }
          // eslint-disable-next-line radix
          const fileSize = parseInt(header['content-length']) || 0
          const contentType = header['content-type'] || ''

          if ([400, 404].includes(Number(res.statusCode))) {
            return {
              code: 'FILE_NOT_FOUND',
              fileID: item.fileID,
              tempFileURL: item.tempFileURL,
              message: 'file not found',
            }
          }

          const fileInfo = {
            code: item.code,
            fileID: item.fileID,
            tempFileURL: item.tempFileURL,
            cloudId: item.fileID,
            fileName: item.fileID.split('/').pop(),
            contentType,
            mime: contentType.split(';')[0].trim(),
            size: fileSize,
            etag: header.etag || '',
            lastModified: header['last-modified'] || '',
            cacheControl: header['cache-control'] || '',
          }

          return fileInfo
        } catch (e) {
          return {
            code: 'FETCH_FILE_INFO_ERROR',
            fileID: item.fileID,
            tempFileURL: item.tempFileURL,
            message: e.message,
          }
        }
      }),)

      return {
        fileList,
        requestId: fileInfo.requestId,
      }
    }

    return {
      fileList: [],
      requestId: fileInfo.requestId,
    }
  }
}
