"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebAiMethods = exports.createWebAiAPI = void 0;
const utils_1 = require("../common/utils");
const weda_cloud_sdk_1 = require("@cloudbase/weda-cloud-sdk");
function createWebAiAPI() {
    const getAi = async () => {
        const cloudbaseApp = await weda_cloud_sdk_1.CLOUD_SDK.getCloudInstance();
        return cloudbaseApp.ai();
    };
    return {
        ai: (0, exports.createWebAiMethods)({
            getAi,
        }),
    };
}
exports.createWebAiAPI = createWebAiAPI;
const DEFAULT_STREAM_TIMEOUT = 60 * 3 * 1000;
const createWebAiMethods = ({ getAi }) => {
    const LLM = {
        chat: async (params, $w) => {
            const { callEventFlow, getVarValue, setVarValue } = (0, utils_1.generateMethodsFrom$w)($w);
            const { provider, model, messages, stream, varPath, setStateType, callbackEventFlowId, temperature: _temperature, top_p: _top_p, timeout = DEFAULT_STREAM_TIMEOUT, } = params;
            const ai = await getAi();
            const llmModel = ai.createModel(provider);
            const data = { model, messages };
            const [top_p, temperature] = [_top_p, _temperature].map(utils_1.normalizeNumber);
            if (top_p !== null)
                Object.assign(data, { top_p });
            if (temperature !== null)
                Object.assign(data, { temperature });
            if (stream) {
                const streamRes = await llmModel.streamText(data, { timeout });
                const ret = {
                    textStream: streamRes.textStream,
                    eventStream: streamRes.dataStream,
                };
                const setResultToVar = async () => {
                    if (varPath) {
                        let beginningStr = setStateType === 'append' ? getVarValue(varPath) ?? '' : '';
                        const [retTextStream, readTextStream] = streamRes.textStream.tee().map(createAsyncIterable);
                        ret.textStream = retTextStream;
                        for await (let text of readTextStream) {
                            beginningStr += text;
                            setVarValue(varPath, beginningStr);
                        }
                    }
                };
                const callCallbackEventFlow = async () => {
                    if (callbackEventFlowId) {
                        const [retDataStream, readDataStream] = streamRes.dataStream.tee().map(createAsyncIterable);
                        ret.eventStream = retDataStream;
                        for await (let event of readDataStream) {
                            callEventFlow(callbackEventFlowId, event);
                        }
                    }
                };
                await Promise.all([setResultToVar(), callCallbackEventFlow()]);
                return ret;
            }
            else {
                const generateRes = await llmModel.generateText(data, { timeout });
                if (varPath) {
                    let beginningStr = setStateType === 'append' ? getVarValue(varPath) ?? '' : '';
                    beginningStr += generateRes.text;
                    setVarValue(varPath, beginningStr);
                }
                return generateRes.rawResponses[0];
            }
        },
    };
    const bot = {
        getRecommendQuestions: async (params, $w) => {
            const { callEventFlow, getVarValue, setVarValue } = (0, utils_1.generateMethodsFrom$w)($w);
            const { varPath, setStateType, callbackEventFlowId, timeout = DEFAULT_STREAM_TIMEOUT, ...restParams } = params;
            const ai = await getAi();
            const streamRes = await ai.bot.getRecommendQuestions(restParams, { timeout });
            const ret = {
                textStream: streamRes.textStream,
                eventStream: streamRes.dataStream,
            };
            const setResultToVar = async () => {
                if (varPath) {
                    let beginningStr = setStateType === 'append' ? getVarValue(varPath) ?? '' : '';
                    const [retTextStream, readTextStream] = streamRes.textStream.tee().map(createAsyncIterable);
                    ret.textStream = retTextStream;
                    for await (let text of readTextStream) {
                        beginningStr += text;
                        setVarValue(varPath, beginningStr);
                    }
                }
            };
            const callCallbackEventFlow = async () => {
                if (callbackEventFlowId) {
                    const [retDataStream, readDataStream] = streamRes.dataStream.tee().map(createAsyncIterable);
                    ret.eventStream = retDataStream;
                    for await (let event of readDataStream) {
                        callEventFlow(callbackEventFlowId, event);
                    }
                }
            };
            await Promise.all([setResultToVar(), callCallbackEventFlow()]);
            return ret;
        },
        sendMessage: async (params, $w) => {
            const { callEventFlow, getVarValue, setVarValue } = (0, utils_1.generateMethodsFrom$w)($w);
            const { varPath, setStateType, callbackEventFlowId, timeout = DEFAULT_STREAM_TIMEOUT, ...restParams } = params;
            const ai = await getAi();
            const streamRes = await ai.bot.sendMessage(restParams, { timeout });
            const ret = {
                textStream: streamRes.textStream,
                eventStream: streamRes.dataStream,
            };
            const setResultToVar = async () => {
                if (varPath) {
                    let beginningStr = setStateType === 'append' ? getVarValue(varPath) ?? '' : '';
                    const [retTextStream, readTextStream] = streamRes.textStream.tee().map(createAsyncIterable);
                    ret.textStream = retTextStream;
                    for await (let text of readTextStream) {
                        beginningStr += text;
                        setVarValue(varPath, beginningStr);
                    }
                }
            };
            const callCallbackEventFlow = async () => {
                if (callbackEventFlowId) {
                    const [retDataStream, readDataStream] = streamRes.dataStream.tee().map(createAsyncIterable);
                    ret.eventStream = retDataStream;
                    for await (let event of readDataStream) {
                        callEventFlow(callbackEventFlowId, event);
                    }
                }
            };
            await Promise.all([setResultToVar(), callCallbackEventFlow()]);
            return ret;
        },
    };
    [
        'list',
        'get',
        'getChatRecords',
        'sendFeedback',
        'getFeedback',
        'getPreview',
        'uploadFiles',
        'createConversation',
        'getConversation',
        'deleteConversation',
        'speechToText',
        'textToSpeech',
        'getTextToSpeechResult',
    ].forEach((methodName) => {
        bot[methodName] = async (params) => {
            const ai = await getAi();
            return ai.bot[methodName](params);
        };
    });
    const ai = {
        LLM,
        bot,
    };
    return ai;
};
exports.createWebAiMethods = createWebAiMethods;
function createAsyncIterable(stream) {
    const _stream = stream;
    _stream[Symbol.asyncIterator] = () => {
        const reader = stream.getReader();
        return {
            async next() {
                const { done, value } = await reader.read();
                return done ? { done: true, value: undefined } : { done: false, value };
            },
        };
    };
    return _stream;
}
