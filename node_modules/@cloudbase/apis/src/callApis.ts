import { ERRORS } from '@cloudbase/utilities/dist/cjs/constants'
import { ICallApiOptions, KV } from '@cloudbase/types'
import { ResponseObject, SDKRequestInterface } from '@cloudbase/adapter-interface'

export async function callApi(callApiOptions: ICallApiOptions, opts?: KV<any>): Promise<ResponseObject['data']> {
  const { name, body, path = '', method = 'POST', headers = {} } = callApiOptions || {}
  const { token } = callApiOptions || {}

  if (!name) {
    throw new Error(JSON.stringify({
      code: ERRORS.INVALID_PARAMS,
      msg: '[apis] invalid api name',
    }),)
  }

  let url = ''

  const { gatewayOrigin, getAccessToken, env } = this

  if (gatewayOrigin) {
    url = `${gatewayOrigin}/v1`
  } else if (this.getEndPointWithKey) {
    const { BASE_URL, PROTOCOL } = this.getEndPointWithKey('GATEWAY')
    url = `${PROTOCOL}${BASE_URL}`
  } else {
    url = `https://${env}.api.tcloudbasegateway.com/v1`
  }
  const endpoint = `${url}/apis/${name}`
  const reqPath = path.startsWith('/') ? path : `/${path}`

  if (getAccessToken) {
    const { accessToken } = (await getAccessToken())
    headers.Authorization = `Bearer ${accessToken}`
  }

  const response = await this.request.fetch({
    url: `${endpoint}${reqPath}`,
    method: method || 'POST',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      ...headers,
    },
    body,
    token: token?.trim?.() || headers.Authorization?.replace?.(/^Bearer /, '') || null,
    ...opts,
  })

  return await response.data
}

const SUPPORT_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', 'PATCH', 'REQUEST']
declare type MethodType = 'request' | 'post' | 'get' | 'head' | 'patch' | 'delete' | 'put';

export function generateCallApis(apiName: string): { [method in MethodType]: typeof callApi } {
  return new Proxy({} as any, {
    get: (_, method) => {
      if (typeof method !== 'string') {
        throw new Error('[apis] method must be string')
      }

      const upMethod = method.toLocaleUpperCase()

      if (!SUPPORT_METHODS.includes(upMethod)) {
        throw new Error(`[apis] invalid method: ${method}`)
      }

      return async (callApiOptions: ICallApiOptions, opts: KV<any>) => await callApi.call(
        this,
        {
          name: apiName,
          method: (upMethod === 'REQUEST' ? callApiOptions.method : upMethod) || 'POST',
          ...callApiOptions,
        },
        opts,
      )
    },
  })
}

export function generateApis(params?: {
  env?: string;
  request?: SDKRequestInterface;
  gatewayOrigin?: string;
  getAccessToken?: () => Promise<{ accessToken: string }>;
}): { [apiName: string]: { [method in MethodType]: typeof callApi } } {
  Object.keys(params || {}).forEach((key) => {
    if (params[key] !== undefined) this[key] = params[key]
  })

  return new Proxy(
    {},
    {
      get: (_, apiName) => {
        if (typeof apiName === 'string') {
          return generateCallApis.call(this, apiName)
        }
      },
    },
  )
}
