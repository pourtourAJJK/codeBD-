import type tcb from '@cloudbase/js-sdk';
import { LANGS } from '@cloudbase/types';
import { IWedaHostUser, ILoginState } from './types';
/**
 * 横跨多包的公共 工具文件
 */
/** 预置的错误对象, 可用该对象抛出自定义错误代码及错误信息 */
export declare class TCBError extends Error {
    /** 错误代码 */
    code: number | string;
    /** 原始的返回结果 */
    original?: {
        requestId: string;
        result: any;
    };
    constructor(code: number | string, message: string, original?: any);
}
/**
 * 对象 obj 是否拥有 key
 */
export declare function hasOwn(obj: any, key: string): boolean;
/**
 * 调用数据源的参数
 */
export interface ICallDataSourceParams {
    /**
     * 数据源标志
     * @deprecated 使用 name 替代, 避免命名冗余
     */
    dataSourceName?: string;
    /**
     * 数据源标识
     */
    name: string;
    /** 数据源方法名 */
    methodName: string;
    /** 方法参数 */
    params: any;
    /** 额外参数 */
    extraParams?: any;
    /** 额外的配置选项 */
    options?: {
        /** 请求过程中是否显示 loading */
        showLoading?: boolean;
        /** 请求结束了, 是否显示toast */
        showToast?: boolean;
    };
    /**
     * 解析云函数返回的的信息, 去除 {code, message, data} 包裹, code 0 返回 data, 否则抛出错误信息
     */
    parseBusinessInfo?: boolean;
}
/** $setDefaultParams 的参数为函数时, 该函数接收的参数结构 */
export interface IDsDefaultParamsFnOptions {
    methodName: string;
    params: any;
}
/** 数据源默认参数, 即 $setDefaultParams 接收的参数  */
export type IDsDefaultParams = Record<string, any> | ((options: IDsDefaultParamsFnOptions) => Record<string, any>);
export type IDataSourceObj = {
    [methodName: string]: (...args: any[]) => Promise<IDataSourceResponse>;
} & {
    $setDefaultParams: (params: IDsDefaultParams) => any;
};
export interface IDataSourceResponse {
    code: number;
    data?: any;
    message?: string;
}
/**
 * 应用所有变量的管理对象
 *  key 为页面id(全局为$global)
 */
export declare const DATASET_CONTEXT: Record<string, {
    params: any;
    state: any;
}>;
/**
 * 基础环境信息
 */
export interface IConfig {
    /**
     * 请求的微搭后台接入层地址, 可通过设置为 prod/pre 来指定地址, 不设置则默认使用 正式地址
     * 为保证该配置能实际生效, 影响所有前端应用发出的请求, 应该尽早设置该值.
     * 建议在应用编辑 -> 低码代码编辑 -> lifecycle 的 onAppLaunch 和 onAppShow 中加入代码 app.cloud.setConfig({wedaTarget: 'xxx'})
     *
     * 可以是下边三个值
     *  'prod' 正式地址
     *  'pre' 预发地址
     *  url 任意一个url
     */
    wedaTarget: string;
    /** 当前是否处于正式发布模式 */
    isProd: boolean;
    /** 低码应用ID */
    appID: string;
    /** 云开发环境ID */
    envID: string;
    /** 云开发环境所属地域 */
    region?: string;
    /** 云开发资源所属的微信app id */
    resourceAppid?: string;
    /** 数据源描述对象数组 */
    dataSourceProfiles: any[];
    /** 初始化TCB的方法 */
    initTcb: (isForce?: boolean) => Promise<any>;
    /**
     * 数据源请求前的钩子, 可用于显示loading弹窗,打日志
     *  params 为数据源请求的原始参数
     */
    beforeDSRequest?: (params: ICallDataSourceParams) => void;
    /**
     * 数据源请求完成后的钩子, 可用于隐藏loading弹窗, 打日志
     *  请求失败时, error 有值, result 为空; 请求成功则相反
     */
    afterDSRequest?: (params: ICallDataSourceParams, error: Error | null, result?: any) => void;
    /**
     * 新的dataset变量配置对象
     *  key 为页面ID(全局为$global), val 为变量配置数组
     */
    datasetProfiles: Record<string, {
        state?: Record<string, any>;
        params?: Record<string, any>;
    }>;
    /**
     * 自定义数据源调用方法
     */
    customCallDataSource?: (params: ICallDataSourceParams) => Promise<unknown>;
    /**
     * 底层callFunction 请求结束后的钩子
     * params 为请求参数
     * error 请求失败时的错误对象
     * result 请求成功时的返回值
     */
    afterCallFunction?: (params: Record<string, any>, error: Error | null, result?: Record<string, any>) => void;
    /**
     * 是否使用合并前的数据源云函数
     */
    useLegacyDatasource?: boolean;
    /**
     * 当前页面的ID
     *  通过 createDataset 调用来设置
     */
    currentPageId?: string;
    /**
     * 是否为私有化部署，默认为 false
     */
    isPrivate?: boolean;
    /**
     * tcb 接口源 地址, 仅微信小程序中使用该参数
     *  e.g.: https://tcb-api.tencentcloudapi.com
     */
    tcbApiOrigin: string;
    /**
     * tcb sdk 初始化的 clientId
     *    每个微搭 appid 对应唯一一个 clientId
     */
    tcbClientId: string;
    /**
     * 云开发 app.callFunction 请求发送前可用于处理和修改请求参数, 务必返回处理后的参数, 不能返回空
     */
    beforeCallFunction?: (params: Record<string, any>) => Promise<Record<string, any>>;
    /**
     * 后端链路采用类型
     * tcb-api 强制走tcb api链路，目前用于小程序全托管模式（非小程序私密链路）
     */
    endpointType: string;
    privatelink?: {
        jsUrl: {
            vm: string;
        };
        gatewayId: string;
        uin: string;
        host: string;
        port: string;
        pathname?: string;
        publicKey: string;
    };
    getPrivatelinkAdapter?: () => Promise<any>;
    /**
     * 默认登录方式
     * 该实现仅在小程序中使用，且非标准配置，仅为内部使用，请勿使用
     * 如需使用咨询 @rohyang
     * @default anonymous
     */
    __defaultLoginType__?: 'openId' | 'anonymous';
    /**
     * 用户自定义配置信息
     */
    customConfig: {
        loginConfig?: {
            failurePolicy?: 'anonymous_login';
            needSignIn?: boolean;
        };
        wedaUser?: IWedaHostUser;
        appType?: 'portal';
        login?: (params?: {
            app: tcb.app.App;
            auth: any;
            loginState: ILoginState;
            defaultLogin: () => void;
        }) => void;
        forceLogin?: boolean;
        tcbInstance?: tcb.app.App;
    };
    /**
     * 新网关服务的地址
     */
    gatewayOrigin?: string;
    __asyncRequire__: (name: string) => Promise<any>;
    lang?: LANGS;
}
export declare function getConfig(): IConfig;
export declare function getConfig<K extends keyof IConfig>(k: K): IConfig[K];
/**
 * 根据数据源名称查询数据源对应的viewId
 */
export declare function getDataSourceViewId(): void;
/**
 * 更新配置 内部使用
 *  对外暴露的 setConfig 在 ./index-cover 中
 * @param config
 */
export declare function setConfig(config: Partial<IConfig>): void;
export interface IDsKeyInfo {
    id: string;
    name: string;
}
/**
 * 获取数据源云函数名称
 * @param dataSourceName 数据源名称, 如果为数据源的云函数, 则该值必填, 以避免不同数据源云函数间重名
 */
export declare function getDatasourceCloudFnName(dsKeyInfo: IDsKeyInfo): string;
/**
 * 获取数据源公共云函数名称
 * @param needNewFeature 是否为新特性, 新特性只能使用合并后的云函数
 */
export declare function getCommonCloudFnName(needNewFeature?: boolean): string;
/**
 * 浅比较两个数组是否相等
 */
export declare function isSameArray(arr1: any[], arr2: any[]): boolean;
/**
 * 同一个函数、同样的参数只执行一次
 */
export declare function execOnce<T extends (...args: any[]) => any>(fn: T, ...args: any[]): ReturnType<T>;
/**
 * 从对象 value 取出 key 在 keys 中的项, 返回新对象
 * @param obj 值
 * @param keys 字段名称数组
 */
export declare function pick<V extends Record<string, any>>(obj: V, keys: string[]): Record<string, any>;
/** 设置默认参数 */
export declare function setDefaultParams(dsName: string, params: IDsDefaultParams): void;
/**
 * 获取默认参数
 * @param dsName 数据源名称
 * @param options 数据源方法的参数 {methodName, params}, 当默认参数为函数时可接用于修改参数
 * @returns
 */
export declare function getDefaultParams(dsName: string, options: IDsDefaultParamsFnOptions): any;
/**
 * 生成单个数据源的设置默认参数方法
 * @param dsName 数据源名称
 * @returns
 */
export declare function createSetDefaultParams(dsName: string): (params: IDsDefaultParams) => void;
/**
 * 后端链路是否采用tcb api, 小程序需要使用js-sdk
 * tcb-api 强制走tcb api链路，目前用于小程序全托管模式（非小程序私密链路）
 */
export declare function useTcbApi(): boolean;
/**
 * 替代Promise.allSettled，主要考虑兼容性
 * @param promises
 * @returns
 */
export declare function PromiseAllSettled<T>(promises: PromiseLike<T>[]): Promise<{
    status: string;
    value?: T;
    reason?: any;
}[]>;
export declare function isString(val: any): boolean;
export declare function isObject(val: any): boolean;
/**
 * 深拷贝
 * @param {*} value 需要拷贝的值
 * @returns {*} 深拷贝后的值
 * @example
 * const obj = { a: 1, b: { c: 2 } };
 * const newObj = deepClone(obj);
 */
export declare const deepClone: (value: any) => any;
export declare function setDatasetProfiles(obj: IConfig['datasetProfiles']): void;
export declare function getDatasetProfiles(key?: string): {
    state?: Record<string, any> | undefined;
    params?: Record<string, any> | undefined;
} | Record<string, {
    state?: Record<string, any> | undefined;
    params?: Record<string, any> | undefined;
}>;
/**
 * 此处为了打包引用方便
 * copy from https://git.woa.com/QBase/client-side-sdk/tcb-js-sdk-adapters/cloudbase-adapter-privatelink.git/src/oauth
 * 同步修改
 */
export declare class OauthClientStorgeBase {
    readonly localStorage: any;
    constructor(config?: {
        localStorage: any;
    });
    /**
     * Get Item
     * @param {string} key
     * @return {Promise<string | null>}
     */
    getItem(key: string): Promise<string | null>;
    /**
     * Remove Item.
     * @param {string} key
     * @return {Promise<void>}
     */
    removeItem(key: string): Promise<void>;
    /**
     * Set Item.
     * @param {string} key
     * @param {string} value
     * @return {Promise<void>}
     */
    setItem(key: string, value: string): Promise<void>;
    getItemSync(key: string): string | null;
    setItemSync(key: string, value: string): void;
    removeItemSync(key: string): void;
}
export declare function generateOauthClientRequest(request?: (options: {
    url: string;
    method: string;
    headers?: any;
    body?: any;
}) => Promise<any>): ((url: string, options?: {
    [key: string]: any;
    body?: any | null;
    headers?: any | null;
    method?: string | undefined;
} | undefined) => Promise<any>) | undefined;
/**
 * Get url path.
 * @param {string} url
 * @return {string}
 */
export declare function getUrlPath(url: string): string;
export declare function _generatePrivatelinkAdapter(env: IConfig, host?: string): Promise<any>;
export declare function deepMerge(obj1: any, obj2: any): any;
