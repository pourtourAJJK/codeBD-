import { ErrorType } from './consts';
import { ApiUrls, ApiUrlsV2, AUTH_API_PREFIX, AUTH_STATE_CHANGED_TYPE, EVENTS } from '../auth/consts';
import { uuidv4 } from '../utils/uuid';
import { getPathName } from '../utils/index';
import { SinglePromise } from '../utils/function/single-promise';
import { weBtoa } from '../utils/base64';
import { isMp } from '../utils/mp';
import { langEvent } from '@cloudbase/utilities';
const RequestIdHeaderName = 'x-request-id';
const DeviceIdHeaderName = 'x-device-id';
const DeviceIdSectionName = 'device_id';
export const defaultRequest = async function (url, options) {
    let result = null;
    let responseError = null;
    try {
        const copyOptions = Object.assign({}, options);
        if (!copyOptions.method) {
            copyOptions.method = 'GET';
        }
        if (copyOptions.body && typeof copyOptions.body !== 'string') {
            copyOptions.body = JSON.stringify(copyOptions.body);
        }
        const responseResult = await fetch(url, copyOptions);
        const jsonResponse = await responseResult.json();
        if (jsonResponse?.error) {
            responseError = jsonResponse;
            responseError.error_uri = new URL(url).pathname;
        }
        else {
            result = jsonResponse;
        }
    }
    catch (error) {
        responseError = {
            error: ErrorType.UNREACHABLE,
            error_description: error.message,
            error_uri: new URL(url).pathname,
        };
    }
    if (responseError) {
        throw responseError;
    }
    else {
        return result;
    }
};
export const toResponseError = (error, options) => {
    let responseError;
    const formatOptions = options || {};
    if (error instanceof Error) {
        responseError = {
            error: formatOptions.error || ErrorType.LOCAL,
            error_description: formatOptions.error_description || error.message,
            error_uri: formatOptions.error_uri,
            details: formatOptions.details || error.stack,
        };
    }
    else {
        const formatError = error || {};
        responseError = {
            error: formatOptions.error || formatError.error || ErrorType.LOCAL,
            error_description: formatOptions.error_description || formatError.error_description,
            error_uri: formatOptions.error_uri || formatError.error_uri,
            details: formatOptions.details || formatError.details,
        };
    }
    return responseError;
};
export function generateRequestId() {
    return uuidv4();
}
class DefaultStorage {
    constructor(opts) {
        this._env = opts?.env || '';
    }
    async getItem(key) {
        return window.localStorage.getItem(`${key}${this._env}`);
    }
    async removeItem(key) {
        window.localStorage.removeItem(`${key}${this._env}`);
    }
    async setItem(key, value) {
        window.localStorage.setItem(`${key}${this._env}`, value);
    }
    getItemSync(key) {
        return window.localStorage.getItem(`${key}${this._env}`);
    }
    removeItemSync(key) {
        window.localStorage.removeItem(`${key}${this._env}`);
    }
    setItemSync(key, value) {
        window.localStorage.setItem(`${key}${this._env}`, value);
    }
}
export const defaultStorage = new DefaultStorage();
function isCredentialsExpired(credentials) {
    let isExpired = true;
    if (credentials?.expires_at && credentials?.access_token) {
        isExpired = credentials.expires_at < new Date();
    }
    return isExpired;
}
class LocalCredentials {
    constructor(options) {
        this.credentials = null;
        this.accessKeyCredentials = null;
        this.singlePromise = null;
        this.tokenSectionName = options.tokenSectionName;
        this.storage = options.storage;
        this.clientId = options.clientId;
        this.singlePromise = new SinglePromise({ clientId: this.clientId });
        this.credentials = options.credentials || null;
    }
    getStorageCredentialsSync() {
        let credentials = null;
        const tokenStr = this.storage.getItemSync(this.tokenSectionName);
        if (tokenStr !== undefined && tokenStr !== null) {
            try {
                credentials = JSON.parse(tokenStr);
                if (credentials?.expires_at) {
                    credentials.expires_at = new Date(credentials.expires_at);
                }
            }
            catch (error) {
                this.storage.removeItem(this.tokenSectionName);
                credentials = null;
            }
        }
        return credentials;
    }
    async setCredentials(credentials) {
        if (credentials?.expires_in) {
            if (!credentials?.expires_at) {
                credentials.expires_at = new Date(Date.now() + (credentials.expires_in - 30) * 1000);
            }
            if (this.storage) {
                const tokenStr = JSON.stringify(credentials);
                await this.storage.setItem(this.tokenSectionName, tokenStr);
            }
            this.credentials = credentials;
        }
        else {
            if (this.storage) {
                await this.storage.removeItem(this.tokenSectionName);
            }
            this.credentials = null;
        }
    }
    setAccessKeyCredentials(credentials) {
        this.accessKeyCredentials = credentials;
    }
    async getCredentials() {
        return this.singlePromise.run('getCredentials', async () => {
            if (isCredentialsExpired(this.credentials)) {
                const { credentials, isAccessKeyCredentials } = await this.getStorageCredentials();
                if (isAccessKeyCredentials) {
                    return credentials;
                }
                this.credentials = credentials;
            }
            return this.credentials;
        });
    }
    async getStorageCredentials() {
        return this.singlePromise.run('_getStorageCredentials', async () => {
            let credentials = null;
            let isAccessKeyCredentials = false;
            const tokenStr = await this.storage.getItem(this.tokenSectionName);
            if (!!tokenStr) {
                try {
                    credentials = JSON.parse(tokenStr);
                    if (credentials?.expires_at) {
                        credentials.expires_at = new Date(credentials.expires_at);
                    }
                }
                catch (error) {
                    await this.storage.removeItem(this.tokenSectionName);
                    credentials = null;
                }
            }
            else {
                credentials = this.accessKeyCredentials || null;
                isAccessKeyCredentials = true;
            }
            return { credentials, isAccessKeyCredentials };
        });
    }
}
class OAuth2Client {
    constructor(options) {
        this.initializePromise = null;
        this.lockAcquired = false;
        this.pendingInLock = [];
        this.singlePromise = null;
        if (!options.clientSecret) {
            options.clientSecret = '';
        }
        if (!options.clientId && options.env) {
            options.clientId = options.env;
        }
        this.apiOrigin = options.apiOrigin;
        this.apiPath = options.apiPath || AUTH_API_PREFIX;
        this.clientId = options.clientId;
        this.i18n = options.i18n;
        this.eventBus = options.eventBus;
        this.singlePromise = new SinglePromise({ clientId: this.clientId });
        this.retry = this.formatRetry(options.retry, OAuth2Client.defaultRetry);
        if (options.baseRequest) {
            this.baseRequest = options.baseRequest;
        }
        else {
            this.baseRequest = defaultRequest;
        }
        this.tokenInURL = options.tokenInURL;
        this.headers = options.headers;
        this.storage = options.storage || defaultStorage;
        this.localCredentials = new LocalCredentials({
            tokenSectionName: `credentials_${options.clientId}`,
            storage: this.storage,
            clientId: options.clientId,
        });
        this.clientSecret = options.clientSecret;
        if (options.clientId) {
            this.basicAuth = `Basic ${weBtoa(`${options.clientId}:${this.clientSecret}`)}`;
        }
        this.wxCloud = options.wxCloud;
        try {
            if (isMp()) {
                this.useWxCloud = options.useWxCloud;
                if (this.wxCloud === undefined && options.env) {
                    wx.cloud.init({ env: options.env });
                    this.wxCloud = wx.cloud;
                }
            }
        }
        catch (error) {
        }
        this.refreshTokenFunc = options.refreshTokenFunc || this.defaultRefreshTokenFunc;
        this.anonymousSignInFunc = options.anonymousSignInFunc;
        this.onCredentialsError = options.onCredentialsError;
        this.getInitialSession = options.getInitialSession;
        this.onInitialSessionObtained = options.onInitialSessionObtained;
        this.logDebugMessages = options.debug ?? false;
        langEvent.bus.on(langEvent.LANG_CHANGE_EVENT, (params) => {
            this.i18n = params.data?.i18n || this.i18n;
        });
    }
    setGetInitialSession(callback) {
        this.getInitialSession = callback;
    }
    setOnInitialSessionObtained(callback) {
        this.onInitialSessionObtained = callback;
    }
    async initialize(func) {
        if (this.initializePromise) {
            return await this.initializePromise;
        }
        if (func !== undefined) {
            this.initializePromise = func;
            return await this.initializePromise;
        }
        this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))();
        return await this.initializePromise;
    }
    async setCredentials(credentials) {
        await this.initializePromise;
        return this._acquireLock(-1, async () => this.localCredentials.setCredentials(credentials));
    }
    setAccessKeyCredentials(credentials) {
        return this.localCredentials.setAccessKeyCredentials(credentials);
    }
    async getAccessToken() {
        await this.initializePromise;
        const credentials = await this.getCredentials();
        if (credentials?.access_token) {
            return Promise.resolve(credentials.access_token);
        }
        const respErr = { error: ErrorType.UNAUTHENTICATED };
        return Promise.reject(respErr);
    }
    async request(url, options) {
        if (!options) {
            options = {};
        }
        const retry = this.formatRetry(options.retry, this.retry);
        options.headers = { ...options.headers, [this.i18n?.LANG_HEADER_KEY]: this.i18n?.lang };
        if (this.headers) {
            options.headers = {
                ...this.headers,
                ...options.headers,
            };
        }
        if (!options.headers[RequestIdHeaderName]) {
            options.headers[RequestIdHeaderName] = generateRequestId();
        }
        if (!options.headers[DeviceIdHeaderName]) {
            const deviceId = await this.getDeviceId();
            options.headers[DeviceIdHeaderName] = deviceId;
        }
        if (options?.withBasicAuth && this.basicAuth) {
            options.headers.Authorization = this.basicAuth;
        }
        if (options?.withCredentials) {
            const credentials = options.getCredentials ? await options.getCredentials() : await this.getCredentials();
            if (credentials) {
                if (this.tokenInURL) {
                    if (url.indexOf('?') < 0) {
                        url += '?';
                    }
                    url += `access_token=${credentials.access_token}`;
                }
                else {
                    options.headers.Authorization = `${credentials.token_type} ${credentials.access_token}`;
                }
            }
        }
        else {
            if (this.clientId && url.indexOf('client_id') < 0) {
                url += url.indexOf('?') < 0 ? '?' : '&';
                url += `client_id=${this.clientId}`;
            }
        }
        if (url.startsWith('/')) {
            url = `${this.apiOrigin}${this.apiPath}${url}`;
        }
        let response = null;
        const maxRequestTimes = retry + 1;
        for (let requestTime = 0; requestTime < maxRequestTimes; requestTime++) {
            try {
                if (options.useWxCloud || this.useWxCloud) {
                    response = await this.wxCloudCallFunction(url, options);
                }
                else {
                    response = await this.baseRequest(url, options);
                }
                if (!!response?.code) {
                    throw ({
                        error: response.code,
                        error_description: response.message,
                        error_uri: new URL(url).pathname,
                    });
                }
                break;
            }
            catch (responseError) {
                if (options.withCredentials && responseError && responseError.error === ErrorType.UNAUTHENTICATED) {
                    await this.setCredentials(null);
                    return Promise.reject(responseError);
                }
                if (requestTime === retry || !responseError || responseError.error !== 'unreachable') {
                    return Promise.reject(responseError);
                }
            }
            await this.sleep(OAuth2Client.retryInterval);
        }
        return response;
    }
    async wxCloudCallFunction(url, options) {
        let result = null;
        let responseError = null;
        try {
            let userAgent = '';
            try {
                userAgent = await wx.getRendererUserAgent();
            }
            catch (error) { }
            const { result: responseResult } = await this.wxCloud.callFunction({
                name: 'httpOverCallFunction',
                data: {
                    url,
                    method: options.method,
                    headers: {
                        origin: 'https://servicewechat.com',
                        'User-Agent': userAgent,
                        ...options.headers,
                    },
                    body: options.body,
                },
            });
            if (responseResult?.body?.error_code) {
                responseError = responseResult?.body;
                responseError.error_uri = getPathName(url);
            }
            else {
                result = responseResult?.body;
            }
        }
        catch (error) {
            responseError = {
                error: ErrorType.UNREACHABLE,
                error_description: error.message,
                error_uri: getPathName(url),
            };
        }
        if (responseError) {
            throw responseError;
        }
        else {
            return result;
        }
    }
    async getCredentials() {
        await this.initializePromise;
        return this._acquireLock(-1, async () => this._getCredentials());
    }
    getCredentialsSync() {
        const credentials = this.localCredentials.getStorageCredentialsSync();
        return credentials;
    }
    getCredentialsAsync() {
        return this.getCredentials();
    }
    async getScope() {
        const credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            const msg = 'credentials not found';
            this.onCredentialsError?.({ msg });
            return this.unAuthenticatedError(msg);
        }
        return credentials.scope;
    }
    async getGroups() {
        const credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            const msg = 'credentials not found';
            this.onCredentialsError?.({ msg });
            return this.unAuthenticatedError(msg);
        }
        return credentials.groups;
    }
    async refreshToken(credentials, options) {
        await this.initializePromise;
        return this._acquireLock(-1, async () => this._refreshToken(credentials, options));
    }
    async _refreshToken(credentials, options) {
        return this.singlePromise.run('_refreshToken', async () => {
            if (!credentials || !credentials.refresh_token) {
                const msg = 'no refresh token found in credentials';
                this.onCredentialsError?.({ msg });
                return this.unAuthenticatedError(msg);
            }
            try {
                const newCredentials = await this.refreshTokenFunc(credentials.refresh_token, credentials);
                await this.localCredentials.setCredentials(newCredentials);
                this.eventBus?.fire(EVENTS.AUTH_STATE_CHANGED, { event: AUTH_STATE_CHANGED_TYPE.TOKEN_REFRESHED });
                return newCredentials;
            }
            catch (error) {
                if (options?.throwError) {
                    throw error;
                }
                if (error.error === ErrorType.INVALID_GRANT) {
                    await this.localCredentials.setCredentials(null);
                    const msg = error.error_description;
                    this.onCredentialsError?.({ msg });
                    return this.unAuthenticatedError(msg);
                }
                this.onCredentialsError?.({ msg: error.error_description });
                return Promise.reject(error);
            }
        });
    }
    async anonymousLogin(credentials) {
        return this.singlePromise.run('_anonymousLogin', async () => {
            if (this.anonymousSignInFunc) {
                const c = await this.anonymousSignInFunc(credentials);
                credentials = c || (await this.localCredentials.getCredentials());
            }
            else {
                credentials = await this.anonymousSignIn(credentials);
            }
            return credentials;
        });
    }
    checkRetry(retry) {
        let responseError = null;
        if (typeof retry !== 'number' || retry < OAuth2Client.minRetry || retry > OAuth2Client.maxRetry) {
            responseError = {
                error: ErrorType.UNREACHABLE,
                error_description: 'wrong options param: retry',
            };
        }
        if (responseError) {
            throw responseError;
        }
        return retry;
    }
    formatRetry(retry, defaultVale) {
        if (typeof retry === 'undefined') {
            return defaultVale;
        }
        return this.checkRetry(retry);
    }
    async sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    async anonymousSignIn(credentials) {
        return this.singlePromise.run('_anonymous', async () => {
            if (!credentials || credentials.scope !== 'anonymous') {
                return this.unAuthenticatedError('no anonymous in credentials');
            }
            try {
                const newCredentials = await this.request(ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {
                    method: 'POST',
                    withBasicAuth: true,
                    body: {},
                });
                await this.localCredentials.setCredentials(newCredentials);
                return newCredentials;
            }
            catch (error) {
                if (error.error === ErrorType.INVALID_GRANT) {
                    await this.localCredentials.setCredentials(null);
                    return this.unAuthenticatedError(error.error_description);
                }
                return Promise.reject(error);
            }
        });
    }
    async defaultRefreshTokenFunc(refreshToken, credentials) {
        if (refreshToken === undefined || refreshToken === '') {
            const msg = 'refresh token not found';
            this.onCredentialsError?.({ msg });
            return this.unAuthenticatedError(msg);
        }
        let url = ApiUrls.AUTH_TOKEN_URL;
        if (credentials?.version === 'v2') {
            url = ApiUrlsV2.AUTH_TOKEN_URL;
        }
        const newCredentials = await this.request(url, {
            method: 'POST',
            body: {
                client_id: this.clientId,
                client_secret: this.clientSecret,
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
            },
        });
        return { ...newCredentials, version: credentials?.version || 'v1' };
    }
    async getDeviceId() {
        if (this.deviceID) {
            return this.deviceID;
        }
        let deviceId = await this.storage.getItem(DeviceIdSectionName);
        if (!(typeof deviceId === 'string' && deviceId.length >= 16 && deviceId.length <= 48)) {
            deviceId = uuidv4();
            await this.storage.setItem(DeviceIdSectionName, deviceId);
        }
        this.deviceID = deviceId;
        return deviceId;
    }
    unAuthenticatedError(err) {
        const respErr = {
            error: ErrorType.UNAUTHENTICATED,
            error_description: err,
        };
        return Promise.reject(respErr);
    }
    _debug(...args) {
        if (this.logDebugMessages) {
            console.log('[OAuth2Client]', ...args);
        }
    }
    async _initialize() {
        try {
            if (!this.getInitialSession) {
                this._debug('#_initialize()', 'no getInitialSession callback set, skipping');
                return { error: null };
            }
            this._debug('#_initialize()', 'calling getInitialSession callback');
            try {
                const { data, error } = await this.getInitialSession();
                if (data?.session) {
                    this._debug('#_initialize()', 'session obtained from getInitialSession', data.session);
                    await this.localCredentials.setCredentials(data?.session);
                }
                if (this.onInitialSessionObtained) {
                    this._debug('#_initialize()', 'calling onInitialSessionObtained callback');
                    try {
                        await this.onInitialSessionObtained(data, error);
                    }
                    catch (callbackError) {
                        this._debug('#_initialize()', 'error in onInitialSessionObtained', callbackError);
                    }
                }
                if (error) {
                    this._debug('#_initialize()', 'error from getInitialSession', error);
                    return { error };
                }
                return { error: null };
            }
            catch (err) {
                this._debug('#_initialize()', 'exception during getInitialSession', err);
                return { error: err instanceof Error ? err : new Error(String(err)) };
            }
        }
        catch (error) {
            this._debug('#_initialize()', 'unexpected error', error);
            return { error: error instanceof Error ? error : new Error(String(error)) };
        }
        finally {
            this._debug('#_initialize()', 'end');
        }
    }
    async _acquireLock(acquireTimeout, fn) {
        this._debug('#_acquireLock', 'begin', acquireTimeout);
        try {
            if (this.lockAcquired) {
                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
                const result = (async () => {
                    await last;
                    return await fn();
                })();
                this.pendingInLock.push((async () => {
                    try {
                        await result;
                    }
                    catch (_e) {
                    }
                })());
                return result;
            }
            this._debug('#_acquireLock', 'acquiring lock for client', this.clientId);
            try {
                this.lockAcquired = true;
                const result = fn();
                this.pendingInLock.push((async () => {
                    try {
                        await result;
                    }
                    catch (_e) {
                    }
                })());
                await result;
                while (this.pendingInLock.length) {
                    const waitOn = [...this.pendingInLock];
                    await Promise.all(waitOn);
                    this.pendingInLock.splice(0, waitOn.length);
                }
                return await result;
            }
            finally {
                this._debug('#_acquireLock', 'releasing lock for client', this.clientId);
                this.lockAcquired = false;
            }
        }
        finally {
            this._debug('#_acquireLock', 'end');
        }
    }
    async _getCredentials() {
        let credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            const msg = 'credentials not found';
            this.onCredentialsError?.({ msg });
            return this.unAuthenticatedError(msg);
        }
        if (isCredentialsExpired(credentials)) {
            if (credentials.refresh_token) {
                try {
                    credentials = await this._refreshToken(credentials);
                }
                catch (error) {
                    if (credentials.scope === 'anonymous') {
                        credentials = await this.anonymousLogin(credentials);
                    }
                    else {
                        this.onCredentialsError?.({ msg: error.error_description });
                        return Promise.reject(error);
                    }
                }
            }
            else if (credentials.scope === 'anonymous') {
                credentials = await this.anonymousLogin(credentials);
            }
            else {
                const msg = 'no refresh token found in credentials';
                this.onCredentialsError?.({ msg });
                return this.unAuthenticatedError(msg);
            }
        }
        return credentials;
    }
}
OAuth2Client.defaultRetry = 2;
OAuth2Client.minRetry = 0;
OAuth2Client.maxRetry = 5;
OAuth2Client.retryInterval = 1000;
export { OAuth2Client };
