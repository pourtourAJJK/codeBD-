import { ApiUrls, ErrorType } from '../auth/consts';
import { defaultStorage } from '../oauth2client/oauth2client';
import { isMp } from '../utils/mp';
import { openURIWithCallback } from './captcha-dom';
export class Captcha {
    constructor(opts) {
        if (!opts.openURIWithCallback) {
            opts.openURIWithCallback = this.getDefaultOpenURIWithCallback();
        }
        if (!opts.storage) {
            opts.storage = defaultStorage;
        }
        this.config = opts;
        this.tokenSectionName = `captcha_${opts.clientId || opts.env}`;
    }
    isMatch() {
        return this.config?.adapter?.isMatch?.() || isMp();
    }
    async request(url, options) {
        if (!options) {
            options = {};
        }
        if (!options.method) {
            options.method = 'GET';
        }
        const state = `${options.method}:${url}`;
        let reqURL = url;
        if (options.withCaptcha) {
            reqURL = await this.appendCaptchaTokenToURL(url, state, false);
        }
        let resp;
        try {
            resp = await this.config.request(reqURL, options);
        }
        catch (err) {
            if (err.error === ErrorType.CAPTCHA_REQUIRED || err.error === ErrorType.CAPTCHA_INVALID) {
                url = await this.appendCaptchaTokenToURL(url, state, err.error === ErrorType.CAPTCHA_INVALID);
                return this.config.request(url, options);
            }
            return Promise.reject(err);
        }
        return resp;
    }
    getDefaultOpenURIWithCallback() {
        return (url) => openURIWithCallback(url, this.config.oauthInstance);
    }
    async getCaptchaToken(forceNewToken, state) {
        if (!forceNewToken) {
            const captchaToken = await this.findCaptchaToken();
            if (captchaToken) {
                return captchaToken;
            }
        }
        const captchaDataResp = await this.config.request(ApiUrls.CAPTCHA_DATA_URL, {
            method: 'POST',
            body: {
                state,
                redirect_uri: '',
            },
            withCredentials: false,
        });
        const captchaTokenUrl = `${captchaDataResp.data}?state=${encodeURIComponent(state)}&token=${encodeURIComponent(captchaDataResp.token)}`;
        const captchaToken = await this.config.openURIWithCallback(captchaTokenUrl);
        this.saveCaptchaToken(captchaToken);
        return captchaToken.captcha_token;
    }
    async appendCaptchaTokenToURL(url, state, forceNewToken) {
        const captchaToken = await this.getCaptchaToken(forceNewToken, state);
        if (url.indexOf('?') > 0) {
            url += `&captcha_token=${captchaToken}`;
        }
        else {
            url += `?captcha_token=${captchaToken}`;
        }
        return url;
    }
    async saveCaptchaToken(token) {
        token.expires_at = new Date(Date.now() + (token.expires_in - 10) * 1000);
        const tokenStr = JSON.stringify(token);
        await this.config.storage.setItem(this.tokenSectionName, tokenStr);
    }
    async findCaptchaToken() {
        const tokenStr = await this.config.storage.getItem(this.tokenSectionName);
        if (tokenStr !== undefined && tokenStr !== null) {
            try {
                const captchaToken = JSON.parse(tokenStr);
                if (captchaToken?.expires_at) {
                    captchaToken.expires_at = new Date(captchaToken.expires_at);
                }
                const isExpired = captchaToken.expires_at < new Date();
                if (isExpired) {
                    return null;
                }
                return captchaToken.captcha_token;
            }
            catch (error) {
                await this.config.storage.removeItem(this.tokenSectionName);
                return null;
            }
        }
        return null;
    }
}
