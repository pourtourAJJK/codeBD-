/**
 * Single Promise
 */

let jsSdkFnPromiseMap = new Map()
export class SinglePromise {
  private clientId: string

  constructor(options) {
    this.clientId = options?.clientId || ''
    jsSdkFnPromiseMap = (jsSdkFnPromiseMap || new Map()) as Map<string, Promise<any>>
  }

  /**
   * Run single promise.
   * @param {string} key
   * @param {Function} fn
   * @return {Promise<T>}
   */
  async run<T>(key: string, fn: () => Promise<T>): Promise<T> {
    key = `${this.clientId}_${key}`
    let result: Promise<any> = jsSdkFnPromiseMap.get(key)

    if (!(result as any)) {
      result = new Promise<any>((resolve, reject) => {
        (async () => {
          try {
            // The idle promise must be run to prevent _fnPromiseMap from
            // storing the current promise function.
            await this.runIdlePromise()
            const fnResult: Promise<T> = fn()
            resolve(await fnResult)
          } catch (error) {
            reject(error)
          } finally {
            jsSdkFnPromiseMap.delete(key)
          }
        })()
      })
      jsSdkFnPromiseMap.set(key, result)
    }
    return result
  }
  /**
   * Run idle promise.
   * @return {Promise<void>}
   */
  private runIdlePromise(): Promise<void> {
    return Promise.resolve()
  }
}
