import { __spreadArrays } from "tslib";
function shouleBeObject(target) {
    if (target && typeof target === 'object')
        return { res: true };
    return {
        res: false,
        msg: getParameterError({
            correct: 'Object',
            wrong: target
        })
    };
}
function getParameterError(_a) {
    var _b = _a.name, name = _b === void 0 ? '' : _b, para = _a.para, correct = _a.correct, wrong = _a.wrong;
    var parameter = para ? "parameter." + para : 'parameter';
    var errorType = upperCaseFirstLetter(wrong === null ? 'Null' : typeof wrong);
    return name + ":fail parameter error: " + parameter + " should be " + correct + " instead of " + errorType;
}
function upperCaseFirstLetter(string) {
    if (typeof string !== 'string')
        return string;
    string = string.replace(/^./, function (match) { return match.toUpperCase(); });
    return string;
}
function inlineStyle(style) {
    var res = '';
    for (var attr in style)
        res += attr + ": " + style[attr] + ";";
    if (res.indexOf('display: flex;') >= 0)
        res += 'display: -webkit-box;display: -webkit-flex;';
    res = res.replace(/transform:(.+?);/g, function (s, $1) { return s + "-webkit-transform:" + $1 + ";"; });
    res = res.replace(/flex-direction:(.+?);/g, function (s, $1) { return s + "-webkit-flex-direction:" + $1 + ";"; });
    return res;
}
function setTransform(el, val) {
    el.style.transform = val;
    el.style.OTransform = val;
    el.style.msTransform = val;
    el.style.MozTransform = val;
    el.style.WebkitTransform = val;
}
function isFunction(obj) {
    return typeof obj === 'function';
}
function successHandler(success, complete) {
    return function (res) {
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return Promise.resolve(res);
    };
}
function errorHandler(fail, complete) {
    return function (res) {
        isFunction(fail) && fail(res);
        isFunction(complete) && complete(res);
        return Promise.reject(res);
    };
}
function serializeParams(params) {
    if (!params) {
        return '';
    }
    return Object.keys(params)
        .map(function (key) { return (encodeURIComponent(key) + "=" + (typeof (params[key]) === 'object'
        ? encodeURIComponent(JSON.stringify(params[key]))
        : encodeURIComponent(params[key]))); })
        .join('&');
}
function temporarilyNotSupport(apiName) {
    return function () {
        var errMsg = "\u6682\u65F6\u4E0D\u652F\u6301 API " + apiName;
        console.error(errMsg);
        return Promise.reject({
            errMsg: errMsg
        });
    };
}
function weixinCorpSupport(apiName) {
    return function () {
        var errMsg = "h5\u7AEF\u4EC5\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7\u4E2D\u652F\u6301 API " + apiName;
        console.error(errMsg);
        return Promise.reject({
            errMsg: errMsg
        });
    };
}
function permanentlyNotSupport(apiName) {
    return function () {
        var errMsg = "\u4E0D\u652F\u6301 API " + apiName;
        console.error(errMsg);
        return Promise.reject({
            errMsg: errMsg
        });
    };
}
var VALID_COLOR_REG = /^#[0-9a-fA-F]{6}$/;
var isValidColor = function (color) {
    return VALID_COLOR_REG.test(color);
};
var createCallbackManager = function () {
    var callbacks = [];
    /**
     * 添加回调
     * @param {{ callback: function, ctx: any } | function} opt
     */
    var add = function (opt) {
        callbacks.push(opt);
    };
    /**
     * 移除回调
     * @param {{ callback: function, ctx: any } | function} opt
     */
    var remove = function (opt) {
        // let pos = -1
        // callbacks.forEach((callback, k) => {
        //   if (callback === opt) {
        //     pos = k
        //   }
        // })
        var pos = callbacks.findIndex(function (callback) { return callback === opt; }) || -1;
        if (pos > -1) {
            callbacks.splice(pos, 1);
        }
    };
    /**
     * 获取回调函数数量
     * @return {number}
     */
    var count = function () { return callbacks.length; };
    /**
     * 触发回调
     * @param  {...any} args 回调的调用参数
     */
    var trigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        callbacks.forEach(function (opt) {
            if (typeof opt === 'function') {
                opt.apply(void 0, args);
            }
            else {
                var callback = opt.callback, ctx = opt.ctx;
                callback.call.apply(callback, __spreadArrays([ctx], args));
            }
        });
    };
    return {
        add: add,
        remove: remove,
        count: count,
        trigger: trigger
    };
};
var createScroller = function () {
    var el = window;
    var getScrollHeight = el === window
        ? function () { return document.documentElement.scrollHeight; }
        : function () { return el.scrollHeight; };
    var getPos = el === window
        ? function () { return window.pageYOffset; }
        : function () { return el.scrollTop; };
    var getClientHeight = el === window
        ? function () { return window.screen.height; }
        : function () { return el.clientHeight; };
    var listen = function (callback) {
        el.addEventListener('scroll', callback);
        document.body.addEventListener('touchmove', callback);
    };
    var unlisten = function (callback) {
        el.removeEventListener('scroll', callback);
        document.body.removeEventListener('touchmove', callback);
    };
    var isReachBottom = function (distance) {
        if (distance === void 0) { distance = 0; }
        return getScrollHeight() - getPos() - getClientHeight() < distance;
    };
    return { listen: listen, unlisten: unlisten, getPos: getPos, isReachBottom: isReachBottom };
};
var findRef = function (refId, componentInstance) {
    if (componentInstance.isRoute)
        return;
    return componentInstance[refId] || findRef(refId, componentInstance.vnode._owner);
};
/**
 * ease-in-out的函数
 * @param {number} t 0-1的数字
 */
var easeInOut = function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; };
var getTimingFunc = function (easeFunc, frameCnt) {
    return function (x) {
        var t = x / (frameCnt - 1);
        return easeFunc(t);
    };
};
/**
 * use closure function to store document.body.style in memory when loaded
 */
var bodyStatusClosure = (function () {
    var hasCalculated;
    var bodyStyle;
    // use object copy to prevent document.body style read issue
    var bodyCopy = Object.assign({}, document.body.style);
    if (!hasCalculated) {
        bodyStyle = bodyCopy;
    }
    hasCalculated = true;
    return {
        getInlineStyle: function () { return bodyStyle && bodyStyle.cssText; },
        hasCalculated: hasCalculated
    };
})();
/**
 * get scrollTop and compact for all possible browser
 *
 * @returns scrollTop
 */
function getScrollTop() {
    if (document.scrollingElement) {
        return document.scrollingElement.scrollTop;
    }
    else {
        return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    }
}
/**
 * compact for scrollTop
 *
 * for more info @see: https://www.zhangxinxu.com/wordpress/2019/02/document-scrollingelement/
 * @param scrollTop scrollTop which needs to be reset
 */
function setScrollTop(scrollTop) {
    if (document.scrollingElement) {
        document.scrollingElement.scrollTop = scrollTop;
    }
    else {
        document.documentElement.scrollTop = scrollTop;
        document.body.scrollTop = scrollTop;
    }
}
var scrollTop = 0;
/**
 * interactive helper to provide position fixed when modal/toast/actionSheet open.
 * And reset body style as default when close.
 */
var interactiveHelper = function () {
    return {
        handleAfterCreate: function () {
            scrollTop = getScrollTop();
            var bodyFixStyle = {
                'position': 'fixed',
                'width': '100%',
                'overflow': 'hidden',
                'top': -scrollTop + "px"
            };
            document.body.setAttribute('style', inlineStyle(bodyFixStyle));
        },
        handleBeforeDestroy: function () {
            var bodyInlineStyle = bodyStatusClosure.getInlineStyle() || {};
            document.body.setAttribute('style', bodyInlineStyle);
            setScrollTop(scrollTop);
        }
    };
};
function calPxToREM(px) {
    if (+px === 0) {
        return '0';
    }
    return (px / 14).toFixed(4) + 'rem';
}
export { shouleBeObject, getParameterError, inlineStyle, setTransform, successHandler, errorHandler, serializeParams, temporarilyNotSupport, weixinCorpSupport, permanentlyNotSupport, isValidColor, isFunction, createCallbackManager, createScroller, findRef, easeInOut, getTimingFunc, interactiveHelper, calPxToREM };
